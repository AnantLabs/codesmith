<%-- 
Name: Concrete DL Class Template
Author: Chris Lasater
Description: Allows generation of DL Base class from parameters
--%>
<%@ CodeTemplate Language="C#" TargetLanguage="C#" Src="../../Utility/ProjectHelper.cs" Inherits="Utility.ProjectHelper" Description="Single Record Concrete Class Template" %>


<%@ Assembly Name="SchemaExplorer" %>
<%@ Import Namespace="SchemaExplorer" %>

<%@ Assembly Name="System.Design" %>
<%@ Import NameSpace="System.IO" %>
<%@ Import NameSpace="System.Text.RegularExpressions" %>
<%@ Import NameSpace="CodeSmith.CustomProperties" %>
<%@ Assembly Name="CodeSmith.BaseTemplates" %>
<%@ Import NameSpace="CodeSmith.BaseTemplates" %>
<%@ Assembly Name="CodeSmith.CustomProperties" %>
<%@ Import NameSpace="CodeSmith.CustomProperties" %>

using System;
using System.Reflection;
using System.Collections;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;

//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by APOSA CodeSmith Domain Object Template.
//
//     Date:    <%= DateTime.Now.ToString("M/d/yyyy") %>
//     Time:    <%= DateTime.Now.ToString("h:mm tt") %>
//     Version: <%= typeof(CodeTemplate).Assembly.GetName().Version.ToString() %>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace <%= CompanyNameSpace %>.<%=ProjectNameSpace%>.DataLayer.Base
{
    public abstract class DALBase : System.MarshalByRefObject
    {
        #region Private Variables
        private string _connectionString;
        private Type _type;
        private Type[] _interfaces;
        private PropertyInfo[] _properties;        
        private Hashtable _originalValues = new Hashtable();
        private int _recordsAffected = 0;
        #endregion      
        
        #region Constructor
        /// <summary>
        /// 
        /// </summary>        
        public DALBase()
        {
            _type = this.GetType();
            _interfaces = _type.GetInterfaces();
            _properties = _interfaces[0].GetProperties(BindingFlags.Public | BindingFlags.Instance);            
        }

        ~DALBase()
        {
            Dispose();
        }
        #endregion

        #region Disposal and Cleanup
        /// <summary>
        /// Dispose implemented to ensure database connections are closed when done.
        /// </summary>
        public void Dispose()
        {
            _type = null;
            _interfaces = null;
            _properties = null;
        }
        #endregion

        #region Properties
        /// <summary>
        /// 
        /// </summary>
        public string ConnectionString
        {
            get {
                if (string.IsNullOrEmpty(_connectionString))
                {
                    _connectionString = Convert.ToString(
                   System.Configuration.ConfigurationManager.ConnectionStrings[
                       System.Configuration.ConfigurationManager.AppSettings["Environment"]]);
                }
                return _connectionString; }
            set { _connectionString = value; }
        }
        /// <summary>
        /// Gets the number of rows changed, inserted, or deleted by execution of the SearchUberv6 stored procedure.
        /// </summary>
        public int RecordsAffected
        {
            get { return _recordsAffected; }
        }
        
        #endregion        

        #region Public Methods
        /// <summary>
        /// 
        /// </summary>
        /// <returns></returns>
        public IDataReader Execute()
        {
            SqlDataReader reader = null;
            SqlConnection connection = new SqlConnection(ConnectionString);
            SqlCommand command = null;

            connection = new SqlConnection(ConnectionString);

            // Open connection (done on first insert)
            if (connection.State == ConnectionState.Closed)
            {
                connection.ConnectionString = this.ConnectionString;
                connection.Open();
            }

            try
            {
                SelectStoredProcedureNameAttribute storedprocedure;
                storedprocedure = (SelectStoredProcedureNameAttribute)Attribute.GetCustomAttribute(_type, typeof(SelectStoredProcedureNameAttribute));

                // Set up a new command
                command = new SqlCommand(storedprocedure.Name, connection);
                command.CommandType = CommandType.StoredProcedure;
                ///command.CommandTimeout = 10000;

                // Add command parameters
                for (int i = 0; i < _properties.Length; i++)
                {
                    SelectDBPropertyInfoAttribute dbPropertyInfo = (SelectDBPropertyInfoAttribute)Attribute.GetCustomAttribute(_properties[i], typeof(SelectDBPropertyInfoAttribute));
                    if (dbPropertyInfo == null) continue;
                    SqlParameter param = new SqlParameter("@" + _properties[i].Name, _properties[i].GetValue(this, null));
                    param.Direction = dbPropertyInfo.Direction;
                    param.SqlDbType = dbPropertyInfo.SqlType;
                    param.Size = dbPropertyInfo.Size;
                    command.Parameters.Add(param);
                }                

                reader = command.ExecuteReader(CommandBehavior.CloseConnection);
				_recordsAffected = reader.RecordsAffected;
            }
            finally
            {
                command.Dispose();
            }
            return reader;

        }
        /// <summary>
        /// Saves User data into the data base. Performs Insert or Update depending on whether ]
        /// the Guid alrady exists in UserID
        /// </summary>
        /// <param name="userID"></param>
        /// <param name="userName"></param>
        /// <param name="status"></param>
        public int ExecuteNonQuery()
        {
            SqlConnection connection = new SqlConnection(ConnectionString);
            SqlCommand command = null;
            
            try
            {
                // Open connection (done on first insert)
                if (connection.State == ConnectionState.Closed)
                {
                    connection.ConnectionString = this.ConnectionString;
                    connection.Open();                   
                }

                InsertStoredProcedureNameAttribute storedprocedure;
                storedprocedure = (InsertStoredProcedureNameAttribute)Attribute.GetCustomAttribute(_type, typeof(InsertStoredProcedureNameAttribute));

                // Set up a new command
                command = new SqlCommand(storedprocedure.Name, connection);
                command.CommandType = CommandType.StoredProcedure;
                ///command.CommandTimeout = 10000;

                // Add command parameters
                for (int i = 0; i < _properties.Length; i++)
                {
                    ModifyDBPropertyInfoAttribute dbPropertyInfo = (ModifyDBPropertyInfoAttribute)Attribute.GetCustomAttribute(_properties[i], typeof(ModifyDBPropertyInfoAttribute));
                    if (dbPropertyInfo == null) continue;
                    SqlParameter param = new SqlParameter("@" + _properties[i].Name, _properties[i].GetValue(this, null));
                    param.Direction = dbPropertyInfo.Direction;
                    param.SqlDbType = dbPropertyInfo.SqlType;
                    param.Size = dbPropertyInfo.Size;
                    command.Parameters.Add(param);
                }                
                _recordsAffected = command.ExecuteNonQuery();

                for (int i = 0; i < _properties.Length; i++)
                {
                    ModifyDBPropertyInfoAttribute dbPropertyInfo = (ModifyDBPropertyInfoAttribute)Attribute.GetCustomAttribute(_properties[i], typeof(ModifyDBPropertyInfoAttribute));
                    if (dbPropertyInfo == null) continue;
                    
                    if ((command.Parameters["@" + _properties[i].Name].Direction == ParameterDirection.Output || 
                        command.Parameters["@" + _properties[i].Name].Direction == ParameterDirection.InputOutput) &&
                        (command.Parameters["@" + _properties[i].Name].Value != DBNull.Value || dbPropertyInfo.SystemTypeAcceptsNulls))
                        _properties[i].SetValue(this, command.Parameters["@" + _properties[i].Name].Value, null);
                    
                }

            }
            finally
            {
                try
                {
                    if (connection.State == ConnectionState.Open)
                    {
                        connection.Close();
                    }

                    connection.Dispose();
                    command.Dispose();
                }
                catch (Exception) { }
            }
            return _recordsAffected;
        }
        
		
        /// <summary>
        /// This method is used to provide a memento pattern implementation
        /// for setting restore data for properties on the DL classes. 
        /// You should implement this method only if reflection across
        /// multiple rows is not an issue, for instanc ethis might not be 
        /// effcient if you have a collection of 1000000 rows or more.
        /// If you implement this method after a clean Database read, 
        /// you will be assured of being able to restore the original data if a validation fails,
        /// without a refresh from the database.
        /// </summary>
        public void SetRestore()
        {
            _properties = this.GetType().GetProperties();
            _originalValues.Clear();
            for (int i = 0; i < _properties.Length; i++)
            {
                PropertyInfo pi = this.GetType().GetProperty(_properties[i].Name);
                if (pi != null)
                    _originalValues.Add(pi.Name, pi.GetValue(this, null));

            }

        }
        /// <summary>
        /// This method is used to provide a memento pattern implementation
        /// for setting restore data for properties on the DL classes. 
        /// This is called usually in the BLBase.SaveData() method, 
        /// and restores the original validation if validation fails.
        /// </summary>
        public void Restore()
        {
            if (_properties == null) return;
            for (int i = 0; i < _properties.Length; i++)
            {
                PropertyInfo pi = this.GetType().GetProperty(_properties[i].Name);
                if (pi != null && pi.CanWrite && _originalValues.ContainsKey(pi.Name))
                    pi.SetValue(this, _originalValues[pi.Name], null);
            }
        }
        #endregion

    }
}

<script runat="template">
#region Public Methods
public enum AccessibilityEnum
{
    Public,
    Protected,
    Internal,
    ProtectedInternal,
    Private
}

public override string GetFileName()
{
	return this.GetClassName() + ".cs";
}


public string GetClassName()
{
	return "DALBase";	
}
#endregion



</script>