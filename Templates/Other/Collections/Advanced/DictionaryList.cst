<%@ CodeTemplate Language="C#" TargetLanguage="C#" Description="Generates a strongly typed DictionaryList collection." %>
<%@ Property Name="Accessibility" Type="AccessibilityEnum" Category="Options" Description="The accessibility of the collection class." %>
<%@ Property Name="ClassName" Type="System.String" Optional="True" Category="Context" Description="The name of the collection class." %>
<%@ Property Name="TargetNamespace" Type="System.String" Optional="True" Category="Namespaces" Description="The namespace of the collection class." %>
<%@ Property Name="ImportNamespace" Type="System.String" Optional="True" Category="Namespaces" Description="The namespace of a collection interface." %>
<%@ Property Name="KeyType" Type="System.String" Category="Context" Description="The key type of the collection." %>
<%@ Property Name="KeyNamespace" Type="System.String" Optional="True" Category="Namespaces" Description="The namespace of the key type." %>
<%@ Property Name="KeyCustomSearch" Type="System.Boolean" Category="Options" Default="false" Description="Use custom search routines for KeyType." %>
<%@ Property Name="KeyValueType" Type="System.Boolean" Category="Context" Default="false" Description="Indicates whether KeyType is a value type." %>
<%@ Property Name="ItemType" Type="System.String" Category="Context" Description="The element type of the collection." %>
<%@ Property Name="ItemNamespace" Type="System.String" Optional="True" Category="Namespaces" Description="The namespace of the element type." %>
<%@ Property Name="ItemValueType" Type="System.Boolean" Category="Context" Default="false" Description="Indicates whether ItemType is a value type." %>
<%@ Property Name="ItemCustomSearch" Type="System.Boolean" Category="Options" Default="false" Description="Use custom search routines for ItemType." %>
<%@ Property Name="PairType" Type="System.String" Optional="True" Category="Context" Description="The key-and-value pair type of the collection." %>
<%@ Property Name="DeepCopy" Type="System.Boolean" Optional="True" Category="Deep Copy" Default="false" Description="Generate deep copy method for the collection." %>
<%@ Property Name="DeepCopyItem" Type="System.String" Optional="True" Category="Deep Copy" Default="Clone" Description="The ItemType method that creates a deep copy." %>
<%@ Property Name="IncludeInterfaces" Type="System.Boolean" Optional="True" Category="Options" Default="true" Description="Generate required interface definitions." %>
<%@ Property Name="IncludeNamespaces" Type="System.Boolean" Optional="True" Category="Namespaces" Default="true" Description="Generate using and namespace statements." %>
<script runat="template">
<!-- #include file="CommonScript.cs" -->

public override string GetFileName() {
    ValidateClassName("Collection");
    return ClassName + ".cs";
}

public void ValidateClassName(string suffix) {
    if (ClassName == null || ClassName.Length == 0)
        ClassName = KeyType + ItemType + suffix;
}

public void ValidatePairType() {
    if (PairType == null || PairType.Length == 0)
        PairType = KeyType + ItemType + "Entry";
}

</script>
<% ValidateClassName("Collection"); %>
<% ValidatePairType(); %>
<% UsingNamespace("System"); %>
<% UsingNamespace("System.Collections"); %>
<% UsingNamespace(KeyNamespace); %>
<% UsingNamespace(ItemNamespace); %>
<% UsingNamespace(ImportNamespace); %>
<% StartNamespace(TargetNamespace); %>
    <% if (IncludeInterfaces) GenerateInterfaces("IDictionary.cst"); %>
    #region Class <%= ClassName %>

    /// <summary>
    /// Implements a strongly typed collection of <see cref="<%= PairType %>"/> key-and-value
    /// pairs that retain their insertion order and are accessible by index and by key.
    /// </summary>
    /// <remarks><para>
    /// <b><%= ClassName %></b> provides an <see cref="ArrayList"/> that is strongly
    /// typed for <see cref="<%= PairType %>"/> elements and allows direct access to
    /// its <see cref="<%= KeyType %>"/> keys and <see cref="<%= ItemType %>"/> values.
    /// </para><para>
    /// The collection may contain multiple identical keys. All key access methods return the
    /// first occurrence of the specified key, if found. Access by index is an O(1) operation
    /// but access by key or value are both O(<em>N</em>) operations, where <em>N</em> is the
    /// current value of the <see cref="<%= ClassName %>.Count"/> property.
    /// </para></remarks>

    [Serializable]
    <%= GetAccessModifier(Accessibility) %> class <%= ClassName %>:
        I<%= KeyType %><%= ItemType %>List, IList, ICloneable {
        #region Private Fields

        private const int _defaultCapacity = 16;

        private <%= KeyType %>[] _keys;
        private <%= ItemType %>[] _values;
        private int _count;

        [NonSerialized]
        private int _version;
        private KeyList _keyList;
        private ValueList _valueList;

        #endregion
        #region Private Constructors

        // helper type to identify private ctor
        private enum Tag { Default }

        private <%= ClassName %>(Tag tag) { }

        #endregion
        #region Public Constructors
        #region <%= ClassName %>()

        /// <overloads>
        /// Initializes a new instance of the <see cref="<%= ClassName %>"/> class.
        /// </overloads>
        /// <summary>
        /// Initializes a new instance of the <see cref="<%= ClassName %>"/> class
        /// that is empty and has the default initial capacity.
        /// </summary>
        /// <remarks>Please refer to <see cref="ArrayList()"/> for details.</remarks>

        public <%= ClassName %>() {
            this._keys = new <%= KeyType %>[_defaultCapacity];
            this._values = new <%= ItemType %>[_defaultCapacity];
        }

        #endregion
        #region <%= ClassName %>(Int32)

        /// <summary>
        /// Initializes a new instance of the <see cref="<%= ClassName %>"/> class
        /// that is empty and has the specified initial capacity.
        /// </summary>
        /// <param name="capacity">The number of elements that the new
        /// <see cref="<%= ClassName %>"/> is initially capable of storing.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="capacity"/> is less than zero.</exception>
        /// <remarks>Please refer to <see cref="ArrayList(Int32)"/> for details.</remarks>

        public <%= ClassName %>(int capacity) {
            if (capacity < 0)
                throw new ArgumentOutOfRangeException("capacity",
                    capacity, "Argument cannot be negative.");

            this._keys = new <%= KeyType %>[capacity];
            this._values = new <%= ItemType %>[capacity];
        }

        #endregion
        #region <%= ClassName %>(<%= ClassName %>)

        /// <summary>
        /// Initializes a new instance of the <see cref="<%= ClassName %>"/> class
        /// that contains elements copied from the specified collection and
        /// that has the same initial capacity as the number of elements copied.
        /// </summary>
        /// <param name="collection">The <see cref="<%= ClassName %>"/>
        /// whose elements are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="ArrayList(ICollection)"/> for details.</remarks>

        public <%= ClassName %>(<%= ClassName %> collection) {
            if (collection == null)
                throw new ArgumentNullException("collection");

            this._keys = new <%= KeyType %>[collection.Count];
            this._values = new <%= ItemType %>[collection.Count];
            AddRange(collection);
        }

        #endregion
        #region <%= ClassName %>(<%= PairType %>[])

        /// <summary>
        /// Initializes a new instance of the <see cref="<%= ClassName %>"/> class
        /// that contains elements copied from the specified <see cref="<%= PairType %>"/>
        /// array and that has the same initial capacity as the number of elements copied.
        /// </summary>
        /// <param name="array">An <see cref="Array"/> of <see cref="<%= PairType %>"/>
        /// elements that are copied to the new collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="ArrayList(ICollection)"/> for details.</remarks>

        public <%= ClassName %>(<%= PairType %>[] array) {
            if (array == null)
                throw new ArgumentNullException("array");

            this._keys = new <%= KeyType %>[array.Length];
            this._values = new <%= ItemType %>[array.Length];
            AddRange(array);
        }

        #endregion
        #endregion
        #region Protected Properties
        #region InnerKeys
        
        /// <summary>
        /// Gets the list of keys contained in the <see cref="<%= ClassName %>"/> instance.
        /// </summary>
        /// <value>
        /// A one-dimensional <see cref="Array"/> with zero-based indexing that contains all 
        /// <see cref="<%= KeyType %>"/> elements in the <see cref="<%= ClassName %>"/>.
        /// </value>
        /// <remarks>
        /// Use <b>InnerKeys</b> to access the key array of a <see cref="<%= ClassName %>"/>
        /// instance that might be a read-only or synchronized wrapper. This is necessary 
        /// because the key and value arrays of wrapper classes are always null references.
        /// </remarks>

        protected virtual <%= KeyType %>[] InnerKeys {
            get { return this._keys; }
        }

        #endregion
        #region InnerValues
        
        /// <summary>
        /// Gets the list of values contained in the <see cref="<%= ClassName %>"/> instance.
        /// </summary>
        /// <value>
        /// A one-dimensional <see cref="Array"/> with zero-based indexing that contains all 
        /// <see cref="<%= ItemType %>"/> elements in the <see cref="<%= ClassName %>"/>.
        /// </value>
        /// <remarks>
        /// Use <b>InnerValues</b> to access the value array of a <see cref="<%= ClassName %>"/>
        /// instance that might be a read-only or synchronized wrapper. This is necessary
        /// because the key and value arrays of wrapper classes are always null references.
        /// </remarks>

        protected virtual <%= ItemType %>[] InnerValues {
            get { return this._values; }
        }

        #endregion
        #endregion
        #region Public Properties
        #region Capacity

        /// <summary>
        /// Gets or sets the capacity of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <value>The number of elements that the
        /// <see cref="<%= ClassName %>"/> can contain.</value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <b>Capacity</b> is set to a value that is less than <see cref="Count"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Capacity"/> for details.</remarks>

        public virtual int Capacity {
            get { return this._keys.Length; }
            set {
                if (value == this._keys.Length) return;

                if (value < this._count)
                    throw new ArgumentOutOfRangeException("Capacity",
                        value, "Value cannot be less than Count.");

                if (value == 0) {
                    this._keys = new <%= KeyType %>[_defaultCapacity];
                    this._values = new <%= ItemType %>[_defaultCapacity];
                    return;
                }

                <%= KeyType %>[] newKeys = new <%= KeyType %>[value];
                <%= ItemType %>[] newValues = new <%= ItemType %>[value];

                Array.Copy(this._keys, 0, newKeys, 0, this._count);
                Array.Copy(this._values, 0, newValues, 0, this._count);

                this._keys = newKeys;
                this._values = newValues;
            }
        }

        #endregion
        #region Count

        /// <summary>
        /// Gets the number of key-and-value pairs contained
        /// in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <value>The number of key-and-value pairs contained
        /// in the <see cref="<%= ClassName %>"/>.</value>
        /// <remarks>Please refer to <see cref="ArrayList.Count"/> for details.</remarks>

        public virtual int Count {
            get { return this._count; }
        }

        #endregion
        #region IsFixedSize

        /// <summary>
        /// Gets a value indicating whether the <see cref="<%= ClassName %>"/> has a fixed size.
        /// </summary>
        /// <value><c>true</c> if the <see cref="<%= ClassName %>"/> has a fixed size;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ArrayList.IsFixedSize"/> for details.</remarks>

        public virtual bool IsFixedSize {
            get { return false; }
        }

        #endregion
        #region IsReadOnly

        /// <summary>
        /// Gets a value indicating whether the <see cref="<%= ClassName %>"/> is read-only.
        /// </summary>
        /// <value><c>true</c> if the <see cref="<%= ClassName %>"/> is read-only;
        /// otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ArrayList.IsReadOnly"/> for details.</remarks>

        public virtual bool IsReadOnly {
            get { return false; }
        }

        #endregion
        #region IsSynchronized

        /// <summary>
        /// Gets a value indicating whether access to the <see cref="<%= ClassName %>"/>
        /// is synchronized (thread-safe).
        /// </summary>
        /// <value><c>true</c> if access to the <see cref="<%= ClassName %>"/> is
        /// synchronized (thread-safe); otherwise, <c>false</c>. The default is <c>false</c>.</value>
        /// <remarks>Please refer to <see cref="ArrayList.IsSynchronized"/> for details.</remarks>

        public virtual bool IsSynchronized {
            get { return false; }
        }

        #endregion
        #region Item: <%= PairType %>

        /// <summary>
        /// Gets or sets the <see cref="<%= PairType %>"/> element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="<%= PairType %>"/> element to get or set.</param>
        /// <value>
        /// The <see cref="<%= PairType %>"/> element at the specified <paramref name="index"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="<%= ClassName %>"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.this"/> for details.</remarks>

        public virtual <%= PairType %> this[int index] {
            get {
                ValidateIndex(index);
                return new <%= PairType %>(this._keys[index], this._values[index]);
            }
            set {
                ValidateIndex(index);
                ++this._version;
                this._keys[index] = value.Key;
                this._values[index] = value.Value;
            }
        }

        #endregion
        #region IList.Item: Object

        /// <summary>
        /// Gets or sets the element at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get or set.</param>
        /// <value>
        /// The element at the specified <paramref name="index"/>, returned as a boxed
        /// <see cref="DictionaryEntry"/> value. When the property is set, this value 
        /// must be compatible with <see cref="<%= PairType %>"/>.
        /// </value>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="InvalidCastException">The property is set to a value
        /// that is not compatible with <see cref="<%= PairType %>"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// The property is set and the <see cref="<%= ClassName %>"/> is read-only.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.this"/> for details.</remarks>
        <%--
          We cast the value to DictionaryEntry before getting or setting it.
          This allows getting/setting the property as DictionaryEntry rather
          than PairType which is highly desirable for generic IList access.

          Explicit casts are necessary because the C# compiler and the CLI
          simply ignore PairType's implicit conversion operators to/from
          DictionaryEntry when a value of either type is boxed as an Object.
        --%>

        object IList.this[int index] {
            get { return (DictionaryEntry) this[index]; }
            set { this[index] = (<%= PairType %>) (DictionaryEntry) value; }
        }

        #endregion
        #region Keys

        /// <summary>
        /// Gets an <see cref="I<%= KeyType %>Collection"/> containing
        /// the keys in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <value>An <see cref="I<%= KeyType %>Collection"/> containing
        /// the keys in the <see cref="<%= ClassName %>"/>.</value>
        /// <remarks>Please refer to <see cref="SortedList.Keys"/> for details.</remarks>

        public virtual I<%= KeyType %>Collection Keys {
            get { return GetKeyList(); }
        }

        #endregion
        #region SyncRoot

        /// <summary>
        /// Gets an object that can be used to synchronize
        /// access to the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <value>An object that can be used to synchronize
        /// access to the <see cref="<%= ClassName %>"/>.</value>
        /// <remarks>Please refer to <see cref="SortedList.SyncRoot"/> for details.</remarks>

        public virtual object SyncRoot {
            get { return this; }
        }

        #endregion
        #region Values

        /// <summary>
        /// Gets an <see cref="I<%= ItemType %>Collection"/> containing
        /// the values in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <value>An <see cref="I<%= ItemType %>Collection"/> containing
        /// the values in the <see cref="<%= ClassName %>"/>.</value>
        /// <remarks>Please refer to <see cref="SortedList.Values"/> for details.</remarks>

        public virtual I<%= ItemType %>Collection Values {
            get { return GetValueList(); }
        }

        #endregion
        #endregion
        #region Public Methods
        #region Add(<%= PairType %>)

        /// <overloads>
        /// Adds an element to the end of the <see cref="<%= ClassName %>"/>.
        /// </overloads>
        /// <summary>
        /// Adds a <see cref="<%= PairType %>"/> to the end of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="entry">The <see cref="<%= PairType %>"/> object
        /// to be added to the end of the <see cref="<%= ClassName %>"/>.</param>
        /// <returns>The <see cref="<%= ClassName %>"/> index at which the
        /// <paramref name="entry"/> has been added.</returns>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Add"/> for details.</remarks>

        public virtual int Add(<%= PairType %> entry) {
            if (this._count == this._keys.Length)
                EnsureCapacity(this._count + 1);

            ++this._version;
            this._keys[this._count] = entry.Key;
            this._values[this._count] = entry.Value;
            return this._count++;
        }

        #endregion
        #region Add(<%= KeyType %>, <%= ItemType %>)

        /// <summary>
        /// Adds an element with the specified <see cref="<%= KeyType %>"/> key and
        /// <see cref="<%= ItemType %>"/> value to the end of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="key">The <see cref="<%= KeyType %>"/> key of the element
        /// to add to the end of the <see cref="<%= ClassName %>"/>.</param>
        /// <param name="value">The <see cref="<%= ItemType %>"/> value of the element
        /// to add to the end of the <see cref="<%= ClassName %>"/>.
        <% if (!ItemValueType) { %>
        /// This argument can be a null reference.
        <% } %>
        /// </param>
        /// <returns>The <see cref="<%= ClassName %>"/> index at which the
        /// new element has been added.</returns>
        <% if (!KeyValueType) { %>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        <% } %>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="SortedList.Add"/> for details but note that
        /// the <see cref="<%= ClassName %>"/> may contain multiple identical keys.</remarks>

        public int Add(<%= KeyType %> key, <%= ItemType %> value) {
        <% if (!KeyValueType) { %>
            if ((object) key == null)
                throw new ArgumentNullException("key");
        <% } %>

            return Add(new <%= PairType %>(key, value));
        }

        #endregion
        #region IList.Add(Object)

        /// <summary>
        /// Adds an <see cref="Object"/> to the end of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="entry">
        /// The object to be added to the end of the <see cref="<%= ClassName %>"/>.
        /// This argument must be compatible with <see cref="<%= PairType %>"/>.</param>
        /// <returns>The <see cref="<%= ClassName %>"/> index at which the
        /// <paramref name="entry"/> has been added.</returns>
        /// <exception cref="InvalidCastException"><paramref name="entry"/>
        /// is not compatible with <see cref="<%= PairType %>"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Add"/> for details.</remarks>

        int IList.Add(object entry) {
            return Add((<%= PairType %>) entry);
        }

        #endregion
        #region AddRange(<%= ClassName %>)

        /// <overloads>
        /// Adds a range of elements to the end of the <see cref="<%= ClassName %>"/>.
        /// </overloads>
        /// <summary>
        /// Adds the elements of another collection to the end of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="collection">The <see cref="<%= ClassName %>"/> whose elements
        /// should be added to the end of the current collection.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.AddRange"/> for details.</remarks>

        public virtual void AddRange(<%= ClassName %> collection) {
            if (collection == null)
                throw new ArgumentNullException("collection");

            if (collection.Count == 0) return;
            if (this._count + collection.Count > this._keys.Length)
                EnsureCapacity(this._count + collection.Count);

            ++this._version;
            Array.Copy(collection.InnerKeys, 0, this._keys, this._count, collection.Count);
            Array.Copy(collection.InnerValues, 0, this._values, this._count, collection.Count);
            this._count += collection.Count;
        }

        #endregion
        #region AddRange(<%= PairType %>[])

        /// <summary>
        /// Adds the elements of a <see cref="<%= PairType %>"/> array
        /// to the end of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="array">An <see cref="Array"/> of <see cref="<%= PairType %>"/> elements
        /// that should be added to the end of the <see cref="<%= ClassName %>"/>.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.AddRange"/> for details.</remarks>

        public virtual void AddRange(<%= PairType %>[] array) {
            if (array == null)
                throw new ArgumentNullException("array");

            if (array.Length == 0) return;
            if (this._count + array.Length > this._keys.Length)
                EnsureCapacity(this._count + array.Length);

            ++this._version;
            for (int i = 0; i < array.Length; ++i, ++this._count) {
                this._keys[this._count] = array[i].Key;
                this._values[this._count] = array[i].Value;
            }
        }

        #endregion
        #region Clear

        /// <summary>
        /// Removes all elements from the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Clear"/> for details.</remarks>

        public virtual void Clear() {
            if (this._count == 0) return;

            ++this._version;
            Array.Clear(this._keys, 0, this._count);
            Array.Clear(this._values, 0, this._count);
            this._count = 0;
        }

        #endregion
        #region Clone

        /// <summary>
        /// Creates a shallow copy of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <returns>A shallow copy of the <see cref="<%= ClassName %>"/>.</returns>
        /// <remarks>Please refer to <see cref="ArrayList.Clone"/> for details.</remarks>

        public virtual object Clone() {
            <%= ClassName %> collection = new <%= ClassName %>(this._count);

            Array.Copy(this._keys, 0, collection._keys, 0, this._count);
            Array.Copy(this._values, 0, collection._values, 0, this._count);

            collection._count = this._count;
            collection._version = this._version;

            return collection;
        }

        #endregion
        #region Contains(<%= PairType %>)

        /// <summary>
        /// Determines whether the <see cref="<%= ClassName %>"/>
        /// contains the specified <see cref="<%= PairType %>"/> element.
        /// </summary>
        /// <param name="entry">The <see cref="<%= PairType %>"/> object
        /// to locate in the <see cref="<%= ClassName %>"/>.</param>
        /// <returns><c>true</c> if <paramref name="entry"/> is found in the
        /// <see cref="<%= ClassName %>"/>; otherwise, <c>false</c>.</returns>
        /// <remarks><para>
        /// Please refer to <see cref="ArrayList.Contains"/> for details.
        /// </para><para>
        /// <b>Contains</b> uses the equality operators defined by <see cref="<%= KeyType %>"/>
        /// and <see cref="<%= ItemType %>"/> to locate the specified <paramref name="entry"/>.
        /// </para></remarks>

        public bool Contains(<%= PairType %> entry) {
            return (IndexOf(entry) >= 0);
        }

        #endregion
        #region IList.Contains(Object)

        /// <summary>
        /// Determines whether the <see cref="<%= ClassName %>"/> contains the specified element.
        /// </summary>
        /// <param name="entry">The object to locate in the <see cref="<%= ClassName %>"/>.
        /// This argument must be compatible with <see cref="<%= PairType %>"/>.</param>
        /// <returns><c>true</c> if <paramref name="entry"/> is found in the
        /// <see cref="<%= ClassName %>"/>; otherwise, <c>false</c>.</returns>
        /// <exception cref="InvalidCastException"><paramref name="entry"/>
        /// is not compatible with <see cref="<%= PairType %>"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Contains"/> for details.</remarks>

        bool IList.Contains(object entry) {
            return Contains((<%= PairType %>) entry);
        }

        #endregion
        #region ContainsKey

        /// <summary>
        /// Determines whether the <see cref="<%= ClassName %>"/>
        /// contains the specified <see cref="<%= KeyType %>"/> key.
        /// </summary>
        /// <param name="key">The <see cref="<%= KeyType %>"/> key
        /// to locate in the <see cref="<%= ClassName %>"/>.</param>
        /// <returns><c>true</c> if the <see cref="<%= ClassName %>"/> contains an element
        /// with the specified <paramref name="key"/>; otherwise, <c>false</c>.</returns>
        <% if (!KeyValueType) { %>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        <% } %>
        /// <remarks>Please refer to <see cref="SortedList.ContainsKey"/> for details but note
        /// that the <see cref="<%= ClassName %>"/> requires linear time to locate a key.</remarks>

        public bool ContainsKey(<%= KeyType %> key) {
            return (IndexOfKey(key) >= 0);
        }

        #endregion
        #region ContainsValue

        /// <summary>
        /// Determines whether the <see cref="<%= ClassName %>"/>
        /// contains the specified <see cref="<%= ItemType %>"/> value.
        /// </summary>
        /// <param name="value">The <see cref="<%= ItemType %>"/> value
        /// to locate in the <see cref="<%= ClassName %>"/>.
        <% if (!ItemValueType) { %>
        /// This argument can be a null reference.
        <% } %>
        /// </param>
        /// <returns><c>true</c> if the <see cref="<%= ClassName %>"/> contains an element
        /// with the specified <paramref name="value"/>; otherwise, <c>false</c>.</returns>
        /// <remarks>Please refer to <see cref="SortedList.ContainsValue"/> for details.</remarks>

        public bool ContainsValue(<%= ItemType %> value) {
            return (IndexOfValue(value) >= 0);
        }

        #endregion
        <% if (DeepCopy) { %>
        #region Copy
        
        /// <summary>
        /// Creates a deep copy of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <returns>A deep copy of the <see cref="<%= ClassName %>"/>.</returns>
        /// <remarks><para>
        <% if (ItemValueType) { %>
        /// <b>Copy</b> has the same effect as <see cref="Clone"/> 
        /// because <see cref="<%= ItemType %>"/> is a value type.
        <% } else if (IsString(ItemType)) { %>
        /// <b>Copy</b> has the same effect as <see cref="Clone"/> 
        /// because strings are immutable in the .NET Framework.
        <% } else { %>
        /// <b>Copy</b> is similar to <see cref="Clone"/> but creates a deep copy of
        /// every <see cref="<%= ItemType %>"/> value in the <see cref="<%= ClassName %>"/>
        /// by invoking its <see cref="<%= ItemType %>.<%= DeepCopyItem %>"/> method.
        /// The <see cref="<%= KeyType %>"/> keys are duplicated by a shallow copy.
        <% } %>
        /// </para><para>
        /// <b>Copy</b> never returns a <b><%= ClassName %></b> with a synchronized
        /// wrapper whereas <b>Clone</b> preserves any present wrapper around this 
        /// <b><%= ClassName %></b>.
        /// </para></remarks>

        public virtual <%= ClassName %> Copy() {
            <%= ClassName %> collection = new <%= ClassName %>(this._count);

            Array.Copy(this._keys, 0, collection._keys, 0, this._count);
        <% if (ItemValueType || IsString(ItemType)) { %>
            Array.Copy(this._values, 0, collection._values, 0, this._count);
        <% } else { %>
            for (int i = 0; i < this._count; i++)
                if ((object) this._values[i] != null)
                    collection._values[i] = (<%= ItemType %>) this._values[i].<%= DeepCopyItem %>();
        <% } %>

            collection._count = this._count;
            collection._version = this._version;

            return collection;
        }
        
        #endregion
        <% } %>
        #region CopyTo(<%= PairType %>[], Int32)

        /// <summary>
        /// Copies the entire <see cref="<%= ClassName %>"/> to a one-dimensional <see cref="Array"/> of
        /// <see cref="<%= PairType %>"/> elements, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="<%= PairType %>"/> elements copied from the <see cref="<%= ClassName %>"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="<%= ClassName %>"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.CopyTo"/> for details.</remarks>

        public virtual void CopyTo(<%= PairType %>[] array, int arrayIndex) {
            CheckTargetArray(array, arrayIndex);

            for (int i = 0; i < this._count; i++)
                array[arrayIndex + i] = 
                    new <%= PairType %>(this._keys[i], this._values[i]);
        }

        #endregion
        #region ICollection.CopyTo(Array, Int32)

        /// <summary>
        /// Copies the entire <see cref="<%= ClassName %>"/> to a one-dimensional <see cref="Array"/>,
        /// starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Array"/> that is the destination of the
        /// <see cref="<%= PairType %>"/> elements copied from the <see cref="<%= ClassName %>"/>.
        /// The <b>Array</b> must have zero-based indexing.</param>
        /// <param name="arrayIndex">The zero-based index in <paramref name="array"/>
        /// at which copying begins.</param>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="array"/> is a null reference.</exception>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <paramref name="arrayIndex"/> is less than zero.</exception>
        /// <exception cref="ArgumentException"><para>
        /// <paramref name="array"/> is multidimensional.
        /// </para><para>-or-</para><para>
        /// <paramref name="arrayIndex"/> is equal to or greater than the length of <paramref name="array"/>.
        /// </para><para>-or-</para><para>
        /// The number of elements in the source <see cref="<%= ClassName %>"/> is greater than
        /// the available space from <paramref name="arrayIndex"/> to the end of the destination
        /// <paramref name="array"/>.</para></exception>
        /// <exception cref="InvalidCastException">
        /// The <see cref="<%= PairType %>"/> type cannot be cast automatically
        /// to the type of the destination <paramref name="array"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.CopyTo"/> for details.</remarks>

        void ICollection.CopyTo(Array array, int arrayIndex) {
            CheckTargetArray(array, arrayIndex);
            CopyTo((<%= PairType %>[]) array, arrayIndex);
        }

        #endregion
        #region Equals

        /// <summary>
        /// Determines whether the specified <see cref="<%= ClassName %>"/>
        /// is equal to the current <b><%= ClassName %></b>.
        /// </summary>
        /// <param name="collection">The <see cref="<%= ClassName %>"/>
        /// to compare with the current <b><%= ClassName %></b>.</param>
        /// <returns><c>true</c> if the specified <see cref="<%= ClassName %>"/> is equal
        /// to the current <b><%= ClassName %></b>; otherwise, <c>false</c>.</returns>
        /// <remarks><para>
        /// This <b>Equals</b> overload tests for value equality of all <see cref="<%= PairType %>"/>
        /// elements contained in the two <see cref="<%= ClassName %>"/> collections.
        /// </para><para>
        /// <b>Equals</b> returns <c>false</c> if <paramref name="collection"/> is a null
        /// reference, holds a different number of elements, or holds at least one
        /// <see cref="<%= PairType %>"/> element at a given index position whose key and/or
        /// value is different from that of the element at the same index position in this
        /// <b><%= ClassName %></b>, as determined by the inequality operators defined by
        /// <see cref="<%= KeyType %>"/> and <see cref="<%= ItemType %>"/>.
        /// </para></remarks>

        public virtual bool Equals(<%= ClassName %> collection) {
            if (collection == null || this._count != collection.Count)
                return false;

            for (int i = 0; i < this._count; i++)
                if (this._keys[i] != collection.InnerKeys[i] ||
                    this._values[i] != collection.InnerValues[i])
                    return false;

            return true;
        }

        #endregion
        #region GetByIndex

        /// <summary>
        /// Gets the <see cref="<%= ItemType %>"/> value at the
        /// specified index of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="<%= ItemType %>"/> value to get.</param>
        /// <returns>The <see cref="<%= ItemType %>"/> value at the specified
        /// <paramref name="index"/> of the <see cref="<%= ClassName %>"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="SortedList.GetByIndex"/> for details.</remarks>

        public virtual <%= ItemType %> GetByIndex(int index) {
            ValidateIndex(index);
            return this._values[index];
        }

        #endregion
        #region GetByKey

        /// <summary>
        /// Gets the <see cref="<%= ItemType %>"/> value associated with the
        /// first occurrence of the specified <see cref="<%= KeyType %>"/> key.
        /// </summary>
        /// <param name="key">The <see cref="<%= KeyType %>"/> key whose value to get.</param>
        /// <returns>The <see cref="<%= ItemType %>"/> value associated with the first occurrence
        /// of the specified <paramref name="key"/>, if found; otherwise,
        <% if (ItemValueType) { %>
        /// a default-initialized <b><%= ItemType %></b> object.
        <% } else { %>
        /// a null reference.
        <% } %>
        /// </returns>
        <% if (!KeyValueType) { %>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        <% } %>
        /// <remarks><b>GetByKey</b> and <see cref="SetByKey"/> emulate the indexer of the
        /// <see cref="SortedList"/> class but require linear time to locate a key.</remarks>

        public virtual <%= ItemType %> GetByKey(<%= KeyType %> key) {
            int index = IndexOfKey(key);
            if (index >= 0) return this._values[index];
        <% if (ItemValueType) { %>
            return new <%= ItemType %>();
        <% } else { %>
            return null;
        <% } %>
        }

        #endregion
        #region GetEnumerator: I<%= KeyType %><%= ItemType %>Enumerator

        /// <summary>
        /// Returns an <see cref="I<%= KeyType %><%= ItemType %>Enumerator"/> that can
        /// iterate through the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <returns>An <see cref="I<%= KeyType %><%= ItemType %>Enumerator"/>
        /// for the entire <see cref="<%= ClassName %>"/>.</returns>
        /// <remarks>Please refer to <see cref="ArrayList.GetEnumerator"/> for details.</remarks>

        public virtual I<%= KeyType %><%= ItemType %>Enumerator GetEnumerator() {
            return new Enumerator(this);
        }

        #endregion
        #region IEnumerable.GetEnumerator: IEnumerator

        /// <summary>
        /// Returns an <see cref="IEnumerator"/> that can
        /// iterate through the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <returns>An <see cref="IEnumerator"/>
        /// for the entire <see cref="<%= ClassName %>"/>.</returns>
        /// <remarks>Please refer to <see cref="ArrayList.GetEnumerator"/> for details.</remarks>

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator) GetEnumerator();
        }

        #endregion
        #region GetKey

        /// <summary>
        /// Gets the <see cref="<%= KeyType %>"/> key at the
        /// specified index of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="<%= KeyType %>"/> key to get.</param>
        /// <returns>The <see cref="<%= KeyType %>"/> key at the specified
        /// <paramref name="index"/> of the <see cref="<%= ClassName %>"/>.</returns>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="SortedList.GetKey"/> for details.</remarks>

        public virtual <%= KeyType %> GetKey(int index) {
            ValidateIndex(index);
            return this._keys[index];
        }

        #endregion
        #region GetKeyList

        /// <summary>
        /// Gets the keys in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <returns>An <see cref="I<%= KeyType %>List"/> containing the keys
        /// in the <see cref="<%= ClassName %>"/>.</returns>
        /// <remarks>Please refer to <see cref="SortedList.GetKeyList"/> for details.</remarks>

        public virtual I<%= KeyType %>List GetKeyList() {
            if (this._keyList == null)
                this._keyList = new KeyList(this);
            return this._keyList;
        }

        #endregion
        #region GetValueList

        /// <summary>
        /// Gets the values in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <returns>An <see cref="I<%= ItemType %>List"/> containing the values
        /// in the <see cref="<%= ClassName %>"/>.</returns>
        /// <remarks>Please refer to <see cref="SortedList.GetValueList"/> for details.</remarks>

        public virtual I<%= ItemType %>List GetValueList() {
            if (this._valueList == null)
                this._valueList = new ValueList(this);
            return this._valueList;
        }

        #endregion
        #region IndexOf(<%= PairType %>)

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="<%= PairType %>"/> in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="entry">The <see cref="<%= PairType %>"/> object
        /// to locate in the <see cref="<%= ClassName %>"/>.</param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="entry"/>
        /// in the <see cref="<%= ClassName %>"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks><para>
        /// Please refer to <see cref="ArrayList.IndexOf"/> for details.
        /// </para><para>
        /// <b>IndexOf</b> uses the equality operators defined by <see cref="<%= KeyType %>"/>
        /// and <see cref="<%= ItemType %>"/> to locate the specified <paramref name="entry"/>.
        /// </para></remarks>

        public virtual int IndexOf(<%= PairType %> entry) {

            for (int i = 0; i < this._count; ++i)
                if (entry.Key == this._keys[i] &&
                    entry.Value == this._values[i])
                    return i;

            return -1;
        }

        #endregion
        #region IList.IndexOf(Object)

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="Object"/> in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="entry">The object to locate in the <see cref="<%= ClassName %>"/>.
        /// This argument must be compatible with <see cref="<%= PairType %>"/>.</param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="entry"/>
        /// in the <see cref="<%= ClassName %>"/>, if found; otherwise, -1.
        /// </returns>
        /// <exception cref="InvalidCastException"><paramref name="entry"/>
        /// is not compatible with <see cref="<%= PairType %>"/>.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.IndexOf"/> for details.</remarks>

        int IList.IndexOf(object entry) {
            return IndexOf((<%= PairType %>) entry);
        }

        #endregion
        #region IndexOfKey

        /// <summary>
        /// Returns the zero-based index of the first occurrence of the specified
        /// <see cref="<%= KeyType %>"/> key in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="key">The <see cref="<%= KeyType %>"/> key
        /// to locate in the <see cref="<%= ClassName %>"/>.</param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="key"/>
        /// in the <see cref="<%= ClassName %>"/>, if found; otherwise, -1.
        /// </returns>
        <% if (!KeyValueType) { %>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        <% } %>
        /// <remarks>Please refer to <see cref="SortedList.IndexOfKey"/> for details but note
        /// that the <see cref="<%= ClassName %>"/> requires linear time to locate a key.</remarks>

        public virtual int IndexOfKey(<%= KeyType %> key) {
        <% if (!KeyValueType) { %>
            if ((object) key == null)
                throw new ArgumentNullException("key");
        <% } %>
        <% if (KeyCustomSearch) { %>

            for (int i = 0; i < this._count; i++)
                if (key.Equals(this._keys[i]))
                    return i;

            return -1;
        <% } else { %>
            return Array.IndexOf(this._keys, key, 0, this._count);
        <% } %>
        }

        #endregion
        #region IndexOfValue

        /// <summary>
        /// Returns the zero-based index of first occurrence of the specified
        /// <see cref="<%= ItemType %>"/> value in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="value">The <see cref="<%= ItemType %>"/> value
        /// to locate in the <see cref="<%= ClassName %>"/>.
        <% if (!ItemValueType) { %>
        /// This argument can be a null reference.
        <% } %>
        /// </param>
        /// <returns>
        /// The zero-based index of the first occurrence of <paramref name="value"/>
        /// in the <see cref="<%= ClassName %>"/>, if found; otherwise, -1.
        /// </returns>
        /// <remarks>Please refer to <see cref="SortedList.IndexOfValue"/> for details.</remarks>

        public virtual int IndexOfValue(<%= ItemType %> value) {
        <% if (ItemCustomSearch) { %>

        <% if (!ItemValueType) { %>
            if ((object) value == null) {
                for (int i = 0; i < this._count; i++)
                    if ((object) this._values[i] == null)
                        return i;

                return -1;
            }
        <% } %>

            for (int i = 0; i < this._count; i++)
                if (value.Equals(this._values[i]))
                    return i;

            return -1;
        <% } else { %>
            return Array.IndexOf(this._values, value, 0, this._count);
        <% } %>
        }

        #endregion
        #region Insert(Int32, <%= PairType %>)

        /// <summary>
        /// Inserts a <see cref="<%= PairType %>"/> element into the
        /// <see cref="<%= ClassName %>"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="entry"/>
        /// should be inserted.</param>
        /// <param name="entry">The <see cref="<%= PairType %>"/> object
        /// to insert into the <see cref="<%= ClassName %>"/>.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Insert"/> for details.</remarks>

        public virtual void Insert(int index, <%= PairType %> entry) {
            if (index < 0)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot be negative.");

            if (index > this._count)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot exceed Count.");

            if (this._count == this._keys.Length)
                EnsureCapacity(this._count + 1);

            ++this._version;
            if (index < this._count) {
                Array.Copy(this._keys, index,
                    this._keys, index + 1, this._count - index);

                Array.Copy(this._values, index,
                    this._values, index + 1, this._count - index);
            }

            this._keys[index] = entry.Key;
            this._values[index] = entry.Value;
            ++this._count;
        }

        #endregion
        #region IList.Insert(Int32, Object)

        /// <summary>
        /// Inserts an element into the <see cref="<%= ClassName %>"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="entry"/>
        /// should be inserted.</param>
        /// <param name="entry">The object to insert into the <see cref="<%= ClassName %>"/>.
        /// This argument must be compatible with <see cref="<%= PairType %>"/>.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="InvalidCastException"><paramref name="entry"/>
        /// is not compatible with <see cref="<%= PairType %>"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Insert"/> for details.</remarks>

        void IList.Insert(int index, object entry) {
            Insert(index, (<%= PairType %>) entry);
        }

        #endregion
        #region Remove(<%= PairType %>)

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="<%= PairType %>"/>
        /// from the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="entry">The <see cref="<%= PairType %>"/> object
        /// to remove from the <see cref="<%= ClassName %>"/>.</param>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Remove"/> for details.</remarks>

        public virtual void Remove(<%= PairType %> entry) {
            int index = IndexOf(entry);
            if (index >= 0) RemoveAt(index);
        }

        #endregion
        #region IList.Remove(Object)

        /// <summary>
        /// Removes the first occurrence of the specified <see cref="Object"/>
        /// from the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="entry">The object to remove from the <see cref="<%= ClassName %>"/>.
        /// This argument must be compatible with <see cref="<%= PairType %>"/>.</param>
        /// <exception cref="InvalidCastException"><paramref name="entry"/>
        /// is not compatible with <see cref="<%= PairType %>"/>.</exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.Remove"/> for details.</remarks>

        void IList.Remove(object entry) {
            Remove((<%= PairType %>) entry);
        }

        #endregion
        #region RemoveAt

        /// <summary>
        /// Removes the element at the specified index of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.RemoveAt"/> for details.</remarks>

        public virtual void RemoveAt(int index) {
            ValidateIndex(index);

            ++this._version;
            if (index < --this._count) {
                Array.Copy(this._keys, index + 1,
                    this._keys, index, this._count - index);

                Array.Copy(this._values, index + 1,
                    this._values, index, this._count - index);
            }

        <% if (KeyValueType) { %>
            this._keys[this._count] = new <%= KeyType %>();
        <% } else { %>
            this._keys[this._count] = null;
        <% } %>
        <% if (ItemValueType) { %>
            this._values[this._count] = new <%= ItemType %>();
        <% } else { %>
            this._values[this._count] = null;
        <% } %>
        }

        #endregion
        #region SetByIndex

        /// <summary>
        /// Sets the <see cref="<%= ItemType %>"/> value at the
        /// specified index of the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="index">The zero-based index of the
        /// <see cref="<%= ItemType %>"/> value to set.</param>
        /// <param name="value">The <see cref="<%= ItemType %>"/> object to store
        /// at the specified <paramref name="index"/> of the <see cref="<%= ClassName %>"/>.
        <% if (!ItemValueType) { %>
        /// This argument can be a null reference.
        <% } %>
        /// </param>
        /// <exception cref="ArgumentOutOfRangeException">
        /// <para><paramref name="index"/> is less than zero.</para>
        /// <para>-or-</para>
        /// <para><paramref name="index"/> is equal to or greater than <see cref="Count"/>.</para>
        /// </exception>
        /// <remarks>Please refer to <see cref="SortedList.SetByIndex"/> for details.</remarks>

        public virtual void SetByIndex(int index, <%= ItemType %> value) {
            ValidateIndex(index);
            ++this._version;
            this._values[index] = value;
        }

        #endregion
        #region SetByKey

        /// <summary>
        /// Sets the <see cref="<%= ItemType %>"/> value associated with the
        /// first occurrence of the specified <see cref="<%= KeyType %>"/> key.
        /// </summary>
        /// <param name="key">The <see cref="<%= KeyType %>"/> key whose value to set.</param>
        /// <param name="value">The <see cref="<%= ItemType %>"/> object to associate with
        /// the first occurrence of the specified <paramref name="key"/>.
        <% if (!ItemValueType) { %>
        /// This argument can be a null reference.
        <% } %>
        /// If the specified <paramref name="key"/> is not found, <b>SetByKey</b> adds a new element
        /// with the specified <paramref name="key"/> and <paramref name="value"/> to the end of the
        /// <see cref="<%= ClassName %>"/>.</param>
        /// <returns>The <see cref="<%= ClassName %>"/> index of the element
        /// that was changed or added.</returns>
        <% if (!KeyValueType) { %>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="key"/> is a null reference.</exception>
        <% } %>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para><paramref name="key"/> does not exist in the collection,
        /// and the <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks><b>SetByKey</b> and <see cref="GetByKey"/> emulate the indexer of the
        /// <see cref="SortedList"/> class but require linear time to locate a key.</remarks>

        public virtual int SetByKey(<%= KeyType %> key, <%= ItemType %> value) {
            int index = IndexOfKey(key);

            if (index >= 0) {
                this._values[index] = value;
                return index;
            }

            return Add(key, value);
        }

        #endregion
        #region Synchronized

        /// <summary>
        /// Returns a synchronized (thread-safe) wrapper
        /// for the specified <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <param name="collection">The <see cref="<%= ClassName %>"/> to synchronize.</param>
        /// <returns>
        /// A synchronized (thread-safe) wrapper around <paramref name="collection"/>.
        /// </returns>
        /// <exception cref="ArgumentNullException">
        /// <paramref name="collection"/> is a null reference.</exception>
        /// <remarks>Please refer to <see cref="ArrayList.Synchronized"/> for details.</remarks>

        public static <%= ClassName %> Synchronized(<%= ClassName %> collection) {
            if (collection == null)
                throw new ArgumentNullException("collection");

            return new SyncList(collection);
        }

        #endregion
        #region ToArray

        /// <summary>
        /// Copies the elements of the <see cref="<%= ClassName %>"/> to a new
        /// <see cref="Array"/> of <see cref="<%= PairType %>"/> elements.
        /// </summary>
        /// <returns>A one-dimensional <see cref="Array"/> of <see cref="<%= PairType %>"/>
        /// elements containing copies of the elements of the <see cref="<%= ClassName %>"/>.
        /// </returns>
        /// <remarks>Please refer to <see cref="ArrayList.ToArray"/> for details.</remarks>

        public virtual <%= PairType %>[] ToArray() {
            <%= PairType %>[] array = new <%= PairType %>[this._count];
            CopyTo(array, 0);
            return array;
        }

        #endregion
        #region TrimToSize

        /// <summary>
        /// Sets the capacity to the actual number of elements in the <see cref="<%= ClassName %>"/>.
        /// </summary>
        /// <exception cref="NotSupportedException">
        /// <para>The <see cref="<%= ClassName %>"/> is read-only.</para>
        /// <para>-or-</para>
        /// <para>The <b><%= ClassName %></b> has a fixed size.</para></exception>
        /// <remarks>Please refer to <see cref="ArrayList.TrimToSize"/> for details.</remarks>

        public virtual void TrimToSize() {
            Capacity = this._count;
        }

        #endregion
        #endregion
        #region Private Methods
        #region CheckEnumIndex

        private void CheckEnumIndex(int index) {
            if (index < 0 || index >= this._count)
                throw new InvalidOperationException(
                    "Enumerator is not on a collection element.");
        }

        #endregion
        #region CheckEnumVersion

        private void CheckEnumVersion(int version) {
            if (version != this._version)
                throw new InvalidOperationException(
                    "Enumerator invalidated by modification to collection.");
        }

        #endregion
        #region CheckTargetArray

        private void CheckTargetArray(Array array, int arrayIndex) {
            if (array == null)
                throw new ArgumentNullException("array");
            if (array.Rank > 1)
                throw new ArgumentException(
                    "Argument cannot be multidimensional.", "array");

            if (arrayIndex < 0)
                throw new ArgumentOutOfRangeException("arrayIndex",
                    arrayIndex, "Argument cannot be negative.");
            if (arrayIndex >= array.Length)
                throw new ArgumentException(
                    "Argument must be less than array length.", "arrayIndex");

            if (this._count > array.Length - arrayIndex)
                throw new ArgumentException(
                    "Argument section must be large enough for collection.", "array");
        }

        #endregion
        #region EnsureCapacity

        private void EnsureCapacity(int minimum) {
            int newCapacity = (this._keys.Length == 0 ?
                _defaultCapacity : this._keys.Length * 2);

            if (newCapacity < minimum) newCapacity = minimum;
            Capacity = newCapacity;
        }

        #endregion
        #region ValidateIndex

        private void ValidateIndex(int index) {
            if (index < 0)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument cannot be negative.");

            if (index >= this._count)
                throw new ArgumentOutOfRangeException("index",
                    index, "Argument must be less than Count.");
        }

        #endregion
        #endregion
        #region Class Enumerator

        [Serializable]
        private sealed class Enumerator:
            I<%= KeyType %><%= ItemType %>Enumerator, IDictionaryEnumerator {
            #region Private Fields

            private readonly <%= ClassName %> _collection;
            private readonly int _version;
            private int _index;

            #endregion
            #region Internal Constructors

            internal Enumerator(<%= ClassName %> collection) {
                this._collection = collection;
                this._version = collection._version;
                this._index = -1;
            }

            #endregion
            #region Public Properties

            public <%= PairType %> Current {
                get { return Entry; }
            }

            object IEnumerator.Current {
                <%-- see DictionaryList.IList.Item --%>
                get { return (DictionaryEntry) Entry; }
            }

            public <%= PairType %> Entry {
                get {
                    this._collection.CheckEnumIndex(this._index);
                    this._collection.CheckEnumVersion(this._version);

                    return new <%= PairType %>(
                        this._collection._keys[this._index],
                        this._collection._values[this._index]);
                }
            }

            DictionaryEntry IDictionaryEnumerator.Entry {
                get { return Entry; }
            }

            public <%= KeyType %> Key {
                get {
                    this._collection.CheckEnumIndex(this._index);
                    this._collection.CheckEnumVersion(this._version);
                    return this._collection._keys[this._index];
                }
            }

            object IDictionaryEnumerator.Key {
                get { return Key; }
            }

            public <%= ItemType %> Value {
                get {
                    this._collection.CheckEnumIndex(this._index);
                    this._collection.CheckEnumVersion(this._version);
                    return this._collection._values[this._index];
                }
            }

            object IDictionaryEnumerator.Value {
                get { return Value; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                this._collection.CheckEnumVersion(this._version);
                return (++this._index < this._collection.Count);
            }

            public void Reset() {
                this._collection.CheckEnumVersion(this._version);
                this._index = -1;
            }

            #endregion
        }

        #endregion
        #region Class KeyList

        [Serializable]
        private sealed class KeyList: I<%= KeyType %>List, IList {
            #region Private Fields

            private <%= ClassName %> _collection;

            #endregion
            #region Internal Constructors

            internal KeyList(<%= ClassName %> collection) {
                this._collection = collection;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._collection.Count; }
            }

            public bool IsReadOnly {
                get { return true; }
            }

            public bool IsFixedSize {
                get { return true; }
            }

            public bool IsSynchronized {
                get { return this._collection.IsSynchronized; }
            }

            public <%= KeyType %> this[int index] {
                get { return this._collection.GetKey(index); }
                set { throw new NotSupportedException(
                        "Read-only collections cannot be modified."); }
            }

            object IList.this[int index] {
                get { return this[index]; }
                set { throw new NotSupportedException(
                        "Read-only collections cannot be modified."); }
            }

            public object SyncRoot {
                get { return this._collection.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public int Add(<%= KeyType %> key) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            int IList.Add(object key) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public void Clear() {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public bool Contains(<%= KeyType %> key) {
                return this._collection.ContainsKey(key);
            }

            bool IList.Contains(object key) {
                return Contains((<%= KeyType %>) key);
            }

            public void CopyTo(<%= KeyType %>[] array, int arrayIndex) {
                this._collection.CheckTargetArray(array, arrayIndex);
                Array.Copy(this._collection._keys, 0,
                    array, arrayIndex, this._collection.Count);
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._collection.CheckTargetArray(array, arrayIndex);
                CopyTo((<%= KeyType %>[]) array, arrayIndex);
            }

            public I<%= KeyType %>Enumerator GetEnumerator() {
                return new KeyEnumerator(this._collection);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            public int IndexOf(<%= KeyType %> key) {
                return this._collection.IndexOfKey(key);
            }

            int IList.IndexOf(object key) {
                return IndexOf((<%= KeyType %>) key);
            }

            public void Insert(int index, <%= KeyType %> key) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            void IList.Insert(int index, object key) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public void Remove(<%= KeyType %> key) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            void IList.Remove(object key) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public void RemoveAt(int index) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            #endregion
        }

        #endregion
        #region Class KeyEnumerator

        [Serializable]
        private sealed class KeyEnumerator:
            I<%= KeyType %>Enumerator, IEnumerator {
            #region Private Fields

            private readonly <%= ClassName %> _collection;
            private readonly int _version;
            private int _index;

            #endregion
            #region Internal Constructors

            internal KeyEnumerator(<%= ClassName %> collection) {
                this._collection = collection;
                this._version = collection._version;
                this._index = -1;
            }

            #endregion
            #region Public Properties

            public <%= KeyType %> Current {
                get {
                    this._collection.CheckEnumIndex(this._index);
                    this._collection.CheckEnumVersion(this._version);
                    return this._collection._keys[this._index];
                }
            }

            object IEnumerator.Current {
                get { return Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                this._collection.CheckEnumVersion(this._version);
                return (++this._index < this._collection.Count);
            }

            public void Reset() {
                this._collection.CheckEnumVersion(this._version);
                this._index = -1;
            }

            #endregion
        }

        #endregion
        #region Class ValueList

        [Serializable]
        private sealed class ValueList: I<%= ItemType %>List, IList {
            #region Private Fields

            private <%= ClassName %> _collection;

            #endregion
            #region Internal Constructors

            internal ValueList(<%= ClassName %> collection) {
                this._collection = collection;
            }

            #endregion
            #region Public Properties

            public int Count {
                get { return this._collection.Count; }
            }

            public bool IsReadOnly {
                get { return true; }
            }

            public bool IsFixedSize {
                get { return true; }
            }

            public bool IsSynchronized {
                get { return this._collection.IsSynchronized; }
            }

            public <%= ItemType %> this[int index] {
                get { return this._collection.GetByIndex(index); }
                set { throw new NotSupportedException(
                    "Read-only collections cannot be modified."); }
            }

            object IList.this[int index] {
                get { return this[index]; }
                set { throw new NotSupportedException(
                    "Read-only collections cannot be modified."); }
            }

            public object SyncRoot {
                get { return this._collection.SyncRoot; }
            }

            #endregion
            #region Public Methods

            public int Add(<%= ItemType %> value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            int IList.Add(object value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public void Clear() {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public bool Contains(<%= ItemType %> value) {
                return this._collection.ContainsValue(value);
            }

            bool IList.Contains(object value) {
                return Contains((<%= ItemType %>) value);
            }

            public void CopyTo(<%= ItemType %>[] array, int arrayIndex) {
                this._collection.CheckTargetArray(array, arrayIndex);
                Array.Copy(this._collection._values, 0,
                    array, arrayIndex, this._collection.Count);
            }

            void ICollection.CopyTo(Array array, int arrayIndex) {
                this._collection.CheckTargetArray(array, arrayIndex);
                CopyTo((<%= ItemType %>[]) array, arrayIndex);
            }

            public I<%= ItemType %>Enumerator GetEnumerator() {
                return new ValueEnumerator(this._collection);
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return (IEnumerator) GetEnumerator();
            }

            public int IndexOf(<%= ItemType %> value) {
                return this._collection.IndexOfValue(value);
            }

            int IList.IndexOf(object value) {
                return IndexOf((<%= ItemType %>) value);
            }

            public void Insert(int index, <%= ItemType %> value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            void IList.Insert(int index, object value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public void Remove(<%= ItemType %> value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            void IList.Remove(object value) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            public void RemoveAt(int index) {
                throw new NotSupportedException(
                    "Read-only collections cannot be modified.");
            }

            #endregion
        }

        #endregion
        #region Class ValueEnumerator

        [Serializable]
        private sealed class ValueEnumerator:
            I<%= ItemType %>Enumerator, IEnumerator {
            #region Private Fields

            private readonly <%= ClassName %> _collection;
            private readonly int _version;
            private int _index;

            #endregion
            #region Internal Constructors

            internal ValueEnumerator(<%= ClassName %> collection) {
                this._collection = collection;
                this._version = collection._version;
                this._index = -1;
            }

            #endregion
            #region Public Properties

            public <%= ItemType %> Current {
                get {
                    this._collection.CheckEnumIndex(this._index);
                    this._collection.CheckEnumVersion(this._version);
                    return this._collection._values[this._index];
                }
            }

            object IEnumerator.Current {
                get { return Current; }
            }

            #endregion
            #region Public Methods

            public bool MoveNext() {
                this._collection.CheckEnumVersion(this._version);
                return (++this._index < this._collection.Count);
            }

            public void Reset() {
                this._collection.CheckEnumVersion(this._version);
                this._index = -1;
            }

            #endregion
        }

        #endregion
        #region Class SyncList

        [Serializable]
        private sealed class SyncList: <%= ClassName %> {
            #region Private Fields

            private <%= ClassName %> _collection;
            private object _root;

            #endregion
            #region Internal Constructors

            internal SyncList(<%= ClassName %> collection):
                base(Tag.Default) {

                this._collection = collection;
                this._root = collection.SyncRoot;
            }

            #endregion
            #region Protected Properties

            protected override <%= KeyType %>[] InnerKeys {
                get { lock (this._root) return this._collection.InnerKeys; }
            }

            protected override <%= ItemType %>[] InnerValues {
                get { lock (this._root) return this._collection.InnerValues; }
            }

            #endregion
            #region Public Properties

            public override int Capacity {
                get { lock (this._root) return this._collection.Capacity; }
            }

            public override int Count {
                get { lock (this._root) return this._collection.Count; }
            }

            public override bool IsFixedSize {
                get { return this._collection.IsFixedSize; }
            }

            public override bool IsReadOnly {
                get { return this._collection.IsReadOnly; }
            }

            public override bool IsSynchronized {
                get { return true; }
            }

            public override <%= PairType %> this[int index] {
                get { lock (this._root) return this._collection[index]; }
                set { lock (this._root) this._collection[index] = value; }
            }

            public override I<%= KeyType %>Collection Keys {
                get { lock (this._root) return this._collection.Keys; }
            }

            public override object SyncRoot {
                get { return this._root; }
            }

            public override I<%= ItemType %>Collection Values {
                get { lock (this._root) return this._collection.Values; }
            }

            #endregion
            #region Public Methods

            public override int Add(<%= PairType %> entry) {
                lock (this._root) return this._collection.Add(entry);
            }

            public override void AddRange(<%= ClassName %> collection) {
                lock (this._root) this._collection.AddRange(collection);
            }

            public override void AddRange(<%= PairType %>[] array) {
                lock (this._root) this._collection.AddRange(array);
            }

            public override void Clear() {
                lock (this._root) this._collection.Clear();
            }

            public override object Clone() {
                lock (this._root)
                    return new SyncList((<%= ClassName %>) this._collection.Clone());
            }
            <% if (DeepCopy) { %>

            public override <%= ClassName %> Copy() {
                lock (this._root) return this._collection.Copy();
            }
            <% } %>

            public override void CopyTo(<%= PairType %>[] array, int index) {
                lock (this._root) this._collection.CopyTo(array, index);
            }

            public override bool Equals(<%= ClassName %> collection) {
                lock (this._root) return this._collection.Equals(collection);
            }

            public override <%= ItemType %> GetByIndex(int index) {
                lock (this._root) return this._collection.GetByIndex(index);
            }

            public override <%= ItemType %> GetByKey(<%= KeyType %> key) {
                lock (this._root) return this._collection.GetByKey(key);
            }

            public override I<%= KeyType %><%= ItemType %>Enumerator GetEnumerator() {
                lock (this._root) return this._collection.GetEnumerator();
            }

            public override <%= KeyType %> GetKey(int index) {
                lock (this._root) return this._collection.GetKey(index);
            }

            public override I<%= KeyType %>List GetKeyList() {
                lock (this._root) return this._collection.GetKeyList();
            }

            public override I<%= ItemType %>List GetValueList() {
                lock (this._root) return this._collection.GetValueList();
            }

            public override int IndexOf(<%= PairType %> entry) {
                lock (this._root) return this._collection.IndexOf(entry);
            }

            public override int IndexOfKey(<%= KeyType %> key) {
                lock (this._root) return this._collection.IndexOfKey(key);
            }

            public override int IndexOfValue(<%= ItemType %> value) {
                lock (this._root) return this._collection.IndexOfValue(value);
            }

            public override void Insert(int index, <%= PairType %> entry) {
                lock (this._root) this._collection.Insert(index, entry);
            }

            public override void Remove(<%= PairType %> entry) {
                lock (this._root) this._collection.Remove(entry);
            }

            public override void RemoveAt(int index) {
                lock (this._root) this._collection.RemoveAt(index);
            }

            public override void SetByIndex(int index, <%= ItemType %> value) {
                lock (this._root) this._collection.SetByIndex(index, value);
            }

            public override int SetByKey(<%= KeyType %> key, <%= ItemType %> value) {
                lock (this._root) return this._collection.SetByKey(key, value);
            }

            public override <%= PairType %>[] ToArray() {
                lock (this._root) return this._collection.ToArray();
            }

            public override void TrimToSize() {
                lock (this._root) this._collection.TrimToSize();
            }

            #endregion
        }

        #endregion
    }

    #endregion
<% EndNamespace(TargetNamespace); %>
