<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>ReadMe for Collection Templates 1.5.0</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="GENERATOR" content="Microsoft Visual Studio.NET 7.1">
    <meta name="vs_targetSchema" content="http://schemas.microsoft.com/intellisense/ie5">
  </head>
  <body>
    <h1>ReadMe for Collection Templates 1.5.0</h1>
    <table frame="void" cellpadding="0" cellspacing="0">
      <tr>
        <td nowrap><strong>Program:</strong></td>
        <td nowrap>&nbsp;Collection Templates for <a href="http://www.ericjsmith.net/codesmith/">
            CodeSmith</a></td>
      </tr>
      <tr>
        <td nowrap><strong>Version:</strong></td>
        <td nowrap>&nbsp;1.5.0</td>
      </tr>
      <tr>
        <td nowrap><strong>Released:</strong></td>
        <td nowrap>&nbsp;1 March 2004</td>
      </tr>
      <tr>
        <td nowrap><strong>Author:</strong></td>
        <td nowrap>&nbsp;Christoph Nahr</td>
      </tr>
      <tr>
        <td nowrap><strong>Contact:</strong></td>
        <td nowrap>&nbsp;<a href="mailto:christoph.nahr@kynosarges.de">christoph.nahr@kynosarges.de</a></td>
      </tr>
      <tr>
        <td nowrap><strong>Website:</strong></td>
        <td nowrap>&nbsp;<a href="http://www.kynosarges.de">http://www.kynosarges.de</a></td>
      </tr>
    </table>
    <h3>Breaking Changes</h3>
    <p>This Collection Templates release requires CodeSmith version 2.5 (build 2.5.10 
      or later).</p>
    <p>Version 1.4.0: The <em>IncludeNamespaces</em> property must be set to <code>false</code>
      when rendering multiple template instances to the same output file. All 
      required namespaces must be declared manually in the CodeSmith custom tool or 
      in your property XML file.</p>
    <p>Version 1.3.0: The new <em>IncludeInterfaces</em> property (for all templates 
      except IList.cst) defaults to <code>true</code> but must be set to <code>false</code>
      in order to reproduce the behavior of previous versions.</p>
    <h2>Table of Contents</h2>
    <ol>
      <li>
        <a href="#Intro">Introduction</a></li>
      <li>
        <a href="#Overview">Overview</a></li>
      <li>
        <a href="#Tutorial">Tutorial</a></li>
      <li>
        <a href="#Templates">Template Files</a></li>
      <li>
        <a href="#Performance">Performance</a></li>
      <li>
        <a href="#History">Version History</a></li>
      <li>
        <a href="#Issues">Known Issues</a></li>
    </ol>
    <h2><a name="Intro">1. Introduction</a></h2>
    <p>The Collection Templates are a set of files that can be used with <a href="http://www.ericjsmith.net/codesmith/">
        CodeSmith</a>, a template-based .NET code generator by Eric J. Smith, to 
      create a variety of strongly typed C# collections. CodeSmith currently requires 
      a Microsoft Windows system with the Microsoft .NET Framework 1.1 installed. 
      Please refer to the CodeSmith website for further details.</p>
    <p>The collection template files and this ReadMe file are copyright © 2003–2004 
      by Christoph Nahr. However, some templates are based on preceding work by <a href="http://www.sellsbrothers.com/">
        Chris Sells</a> who wrote the CollectionGen package that was incorporated 
      into version 2.0 of <a href="http://www.ericjsmith.net/codesmith/">CodeSmith</a>
      by Eric J. Smith. You may freely use, change, and redistribute any or all of 
      the files that constitute the original distribution, but please document any 
      changes and include credits to the persons listed above.</p>
    <h2><a name="Overview">2. Overview</a></h2>
    <p>The directory to which the archive was unpacked contains the following C# 
      template files:</p>
    <ul>
      <li>
        <a href="#ArrayList">ArrayList.cst</a> – strongly typed reimplementation of 
        ArrayList with absolutely no type casting.</li>
      <li>
        <a href="#DictionaryList">DictionaryList.cst</a> – strongly typed 
        implementation of DictionaryList (my invention) with absolutely no type 
        casting.</li>
      <li>
        <a href="#Hashtable">Hashtable.cst</a> – strongly typed wrapper around 
        Hashtable, unfortunately with lots of internal type casting.</li>
      <li>
        <a href="#IDictionary">IDictionary.cst</a> – dictionary interfaces and pair 
        structure required for DictionaryList, Hashtable, and SortedList.</li>
      <li>
        <a href="#IList">IList.cst</a> – collection interfaces required for ArrayList, 
        Queue, Stack, and IDictionary (and hence for the remaining collections).</li>
      <li>
        <a href="#Queue">Queue.cst</a> – strongly typed reimplementation of Queue with 
        absolutely no type casting.</li>
      <li>
        <a href="#SortedList">SortedList.cst</a> – strongly typed reimplementation of 
        SortedList with absolutely no type casting.</li>
      <li>
        <a href="#Stack">Stack.cst</a> – strongly typed reimplementation of Stack with 
        absolutely no type casting.</li>
    </ul>
    <p>The template files do not necessarily offer the complete functionality of the 
      corresponding standard library classes. Some of the more obscure methods and 
      overloads may be missing. Contact me if you require such a feature, and I’ll 
      see if I can implement it in a future version.</p>
    <h3>Classes and Interfaces</h3>
    <p>Each template file provided by this package is either a <strong>class template</strong>
      or an <strong>interface template</strong>. The interface templates define 
      strongly typed collection interfaces that are shared between all classes that 
      use the same element type in some fashion. For instance, if an ArrayList and a 
      hashtable’s Keys collection have the same element type, they will also 
      implement the same strongly typed ICollection.</p>
    <p>The following table shows the interfaces on which each class template relies:</p>
    <ul>
      <li>
        ArrayList.cst, Queue.cst, and Stack.cst – require one IList.cst for the same 
        item type.</li>
      <li>
        DictionaryList.cst, Hashtable.cst, and SortedList.cst – require one 
        IDictionary.cst for the same key type and item type.</li>
      <li>
        IDictionary.cst – requires one IList.cst for the key type and another IList.cst 
        for the item type.</li>
    </ul>
    <p>Note that the interface template IDictionary.cst itself requires two other 
      interface instantiations. The <a href="#Templates">Template Files</a> section 
      covers the requirements in more detail.</p>
    <p>To simplify the creation of collections that don’t share element types with 
      other collections, all required interfaces are automatically generated along 
      with the collection class by default, and placed in the same output file.</p>
    <p>However, this default behavior will lead to name clashes as soon as another 
      collection class is generated that uses the same element type in some fashion. 
      One solution would be to put the generated classes in different target 
      namespaces but this may be undesirable, and would also prevent the sharing of 
      strongly typed interfaces.</p>
    <p>Instead, the optional property <em>IncludeInterfaces</em> (see <a href="#Common">
        Common Properties</a>) should be set to <code>false</code> for all collection 
      classes that require an interface which has already been generated for another 
      collection class. Alternatively, you could set this property to <code>false</code>
      for <em>all</em> collection classes, and manually generate the required 
      interfaces.</p>
    <h2><a name="Tutorial">3. Tutorial</a></h2>
    <p>The following sections describe the template files in detail, but we’ll start 
      out with a quick tutorial that shows how to generate strongly typed collection 
      classes. The tutorial assumes that all properties that are not explicitly 
      mentioned have default values.</p>
    <h3>3.1 Create a strongly typed ArrayList for a reference type <em>T</em></h3>
    <p>Instantiate ArrayList.cst with an <em>ItemType</em> of <em>T</em>. The 
      following types are generated:</p>
    <ul>
      <li>
        The interfaces I<em>T</em>Collection, I<em>T</em>List, and I<em>T</em>Enumerator, 
        all via IList.cst.</li>
      <li>
        The collection class <em>T</em>Collection which is the strongly typed 
        ArrayList.</li>
    </ul>
    <p>You can set the <em>TargetNamespace</em> property as desired to define the 
      namespace in which the generated class and interfaces will reside. Should you 
      choose to manually instantiate IList.cst, you must use the same <em>TargetNamespace</em>
      for both templates.</p>
    <p>The name of the generated collection class can be changed using the <em>ClassName</em>
      property but I generally avoid doing this. The names of the generated 
      interfaces cannot be changed regardless.</p>
    <p><strong>Example.</strong> Creating a strongly typed ArrayList of Button 
      objects would generate the interfaces IButtonCollection, IButtonList, and 
      IButtonEnumerator, and finally the collection class ButtonCollection. 
      ButtonCollection implements IButtonCollection and IButtonList, and its 
      GetEnumerator method returns an IButtonEnumerator. The generic version of all 
      interfaces is also supported.</p>
    <h3>3.2 Create a strongly typed ArrayList for a value type <em>T</em></h3>
    <p>Instantiate ArrayList.cst with an <em>ItemType</em> of <em>T</em> and set <em>ItemValueType</em>
      to <code>true</code>. The following types are generated:</p>
    <ul>
      <li>
        The interfaces I<em>T</em>Collection, I<em>T</em>List, and I<em>T</em>Enumerator, 
        all via IList.cst.</li>
      <li>
        The collection class <em>T</em>Collection which is the strongly typed 
        ArrayList.</li>
    </ul>
    <p>Collection elements are treated as reference types by default. Setting the <em>ItemValueType</em>
      property to <code>true</code> slightly changes the generated code (and XML 
      documentation) to accomodate the unique semantics of value types.</p>
    <h3>3.3 Create a strongly typed Hashtable for keys of type <em>K</em> and values 
      of type <em>V</em></h3>
    <p>Instantiate Hashtable.cst with a <em>KeyType</em> of <em>K</em> and an <em>ItemType</em>
      of <em>V</em>. The following types are generated:</p>
    <ul>
      <li>
        The interfaces I<em>K</em>Collection, I<em>K</em>List, and I<em>K</em>Enumerator, 
        all via IList.cst.</li>
      <li>
        The interfaces I<em>V</em>Collection, I<em>V</em>List, and I<em>V</em>Enumerator, 
        all via IList.cst.</li>
      <li>
        The interfaces I<em>K</em><em>V</em>Collection, I<em>K</em><em>V</em>Dictionary, 
        I<em>K</em><em>V</em>List, and I<em>K</em><em>V</em>Enumerator, as well as the 
        strongly typed DictionaryEntry structure <em>K</em><em>V</em>Entry, all via 
        IDictionary.cst.</li>
      <li>
        The collection class <em>K</em><em>V</em>Dictionary which is the strongly typed 
        Hashtable.</li>
    </ul>
    <p>Set <em>KeyValueType</em> to <code>true</code> if <em>K</em> is a value type, 
      and set <em>ItemValueType</em> to <code>true</code> if <em>V</em> is a value 
      type.</p>
    <p>Should you choose to manually instantiate IList.cst and IDictionary.cst, you 
      must either use the same <em>TargetNamespace</em> for all templates, or you 
      could target different namespaces with each IList.cst instance. In the latter 
      case, you must (arbitrarily) adopt one namespace as the <em>TargetNamespace</em>
      for IDictionary.cst and Hashtable.cst, and use the <em>ImportNamespace</em> property 
      of these two templates to import the other namespace.</p>
    <p><strong>Example.</strong> Creating a strongly typed Hashtable that maps String 
      objects to Button objects would generate the following types:</p>
    <ul>
      <li>
        IStringCollection, IStringList, IStringEnumerator</li>
      <li>
        IButtonCollection, IButtonList, IButtonEnumerator</li>
      <li>
        IStringButtonCollection, IStringButtonDictionary, IStringButtonList, 
        IStringButtonEnumerator, StringButtonEntry</li>
      <li>
        StringButtonDictionary</li>
    </ul>
    <p>StringButtonDictionary implements IStringButtonCollection and 
      IStringButtonDictionary; its elements are StringButtonEntry structures; its 
      GetEnumerator method returns an IStringButtonEnumerator; its Keys list 
      implements IStringCollection and IStringList and provides an IStringEnumerator; 
      and its Values list implements IButtonCollection and IButtonList and provides 
      an IButtonEnumerator. The generic version of all interfaces is also supported.</p>
    <h3>3.4 Create a strongly typed SortedList for keys of type <em>K</em> and values 
      of type <em>V</em>, and a strongly typed ArrayList for elements of type <em>K</em></h3>
    <p>Here we want to share strongly typed interfaces between classes, so we must 
      take care to generate the shared interfaces only once. First, instantiate 
      SortedList.cst with a <em>KeyType</em> of <em>K</em> and an <em>ItemType</em> of
      <em>V</em>. The following types are generated:</p>
    <ul>
      <li>
        The interfaces I<em>K</em>Collection, I<em>K</em>List, and I<em>K</em>Enumerator, 
        all via IList.cst.</li>
      <li>
        The interfaces I<em>V</em>Collection, I<em>V</em>List, and I<em>V</em>Enumerator, 
        all via IList.cst.</li>
      <li>
        The interfaces I<em>K</em><em>V</em>Collection, I<em>K</em><em>V</em>Dictionary, 
        I<em>K</em><em>V</em>List, and I<em>K</em><em>V</em>Enumerator, as well as the 
        strongly typed DictionaryEntry structure <em>K</em><em>V</em>Entry, all via 
        IDictionary.cst.</li>
      <li>
        The collection class <em>K</em><em>V</em>Dictionary which is the strongly typed 
        SortedList.</li>
    </ul>
    <p>Now that we already have the IList.cst instance required for the strongly 
      typed ArrayList, we must instantiate ArrayList.cst with an <em>ItemType</em> of <em>
        K</em> and an <em>IncludeInterfaces</em> property of <code>false</code>. Only 
      a single type is generated:</p>
    <ul>
      <li>
        The collection class <em>K</em>Collection which is the strongly typed 
        ArrayList.</li>
    </ul>
    <p>This ArrayList implements the same strongly typed interfaces as the Keys 
      collection of the SortedList, so either collection could be accessed as an I<em>K</em>Collection 
      or an I<em>K</em>List. Likewise, another strongly typed ArrayList could be 
      created for type <em>V</em>.</p>
    <h2><a name="Templates">4. Template Files</a></h2>
    <p>This section provides reference information for all template files, and is 
      divided into the following subsections:</p>
    <ol>
      <li>
        <a href="#Common">Common Properties</a></li>
      <li>
        <a href="#ArrayList">ArrayList.cst</a></li>
      <li>
        <a href="#DictionaryList">DictionaryList.cst</a></li>
      <li>
        <a href="#Hashtable">Hashtable.cst</a></li>
      <li>
        <a href="#IDictionary">IDictionary.cst</a></li>
      <li>
        <a href="#IList">IList.cst</a></li>
      <li>
        <a href="#Queue">Queue.cst</a></li>
      <li>
        <a href="#SortedList">SortedList.cst</a></li>
      <li>
        <a href="#Stack">Stack.cst</a></li>
    </ol>
    <h3><a name="Common">4.1 Common Properties</a></h3>
    <p>The following properties are available in all template files, except as noted, 
      and always have the same effect.</p>
    <p><em>Accessibility</em> – an enumeration with the possible values Public, 
      Protected, Internal, Protected Internal, and Private. The default is Public. 
      This property determines the visibility of all types defined by a template 
      file, except for private helper classes.</p>
    <p><em>IncludeInterfaces</em> (not with IList.cst) – an optional Boolean value 
      that defaults to <code>true</code>. If set to <code>true</code>, the template 
      file will generate all required interfaces; otherwise, they will be suppressed. 
      In that case you must either manually generate the required interfaces, or have 
      them generated automatically by another template.</p>
    <p><em>IncludeNamespaces</em> – an optional Boolean value that defaults to <code>true</code>. 
      If set to <code>true</code>, the template file will generate all required <code>using</code>
      and <code>namespace</code> statements; otherwise, they will be suppressed. In 
      that case you must ensure that the required statements are generated by other 
      means. Specify the required namespaces in the CodeSmith custom tool, or add 
      &lt;import&gt; elements to your property XML file. – <strong>Note:</strong> This 
      property must be set to <code>false</code> when rendering multiple template 
      instances to the same output file.</p>
    <p><em>ItemNamespace</em> – an optional string that defaults to a null reference. 
      If provided, this property determines the namespace in which <em>ItemType</em> resides. 
      This namespace will be imported by a <code>using</code> statement if <em>IncludeNamespaces</em>
      is <code>true</code>.</p>
    <p><em>ItemValueType</em> – an optional Boolean value that defaults to <code>false</code>. 
      If set to <code>true</code>, this property indicates that <em>ItemType</em> is 
      a value type; otherwise, <em>ItemType</em> is assumed to be a reference type.</p>
    <p><em>KeyNamespace</em> (only with dictionary templates) – an optional string 
      that defaults to a null reference. If provided, this property determines the 
      namespace in which <em>KeyType</em> resides. This namespace will be imported by 
      a <code>using</code> statement if <em>IncludeNamespaces</em> is <code>true</code>.</p>
    <p><em>KeyValueType</em> (only with dictionary templates) – an optional Boolean 
      value that defaults to <code>false</code>. If set to <code>true</code>, this 
      property indicates that <em>KeyType</em> is a value type; otherwise, <em>KeyType</em>
      is assumed to be a reference type.</p>
    <p><em>TargetNamespace</em> – an optional string that defaults to a null 
      reference. If provided, this property determines the namespace in which all 
      types defined by a template file should reside. This namespace will be declared 
      by a <code>namespace</code> statement if <em>IncludeNamespaces</em> is <code>true</code>.</p>
    <h4>Common Class Properties</h4>
    <p>The following properties are available in all template files that define 
      collection classes, except as noted, and always have the same effect. These 
      properties are not available in template files that define interfaces.</p>
    <p>As of version 1.5.0, all class templates provide an optional Copy method to 
      create a deep copy of the collection. This non-standard feature complements the 
      standard Clone method which creates a shallow copy. – <strong>Note:</strong> The 
      keys of dictionary collections are always duplicated as a shallow copy, even by 
      the Copy method.</p>
    <p><em>DeepCopy</em> – an optional Boolean value that defaults to <code>false</code>. 
      If set to <code>true</code>, this property indicates that a Copy method for 
      deep copies should be generated.</p>
    <p><em>DeepCopyItem</em> – an optional string that defaults to “Clone”. This 
      property determines the name of the <em>ItemType</em> method that creates a 
      deep copy of a single collection element (or of its Value part for dictionary 
      collections).</p>
    <p><em>KeyCustomSearch</em> (only with dictionary templates) – an optional 
      Boolean value that defaults to <code>false</code>. If set to <code>true</code>, 
      this property indicates that <em>KeyType</em> searches should be handled by 
      custom routines instead of System.Array methods. Please refer to <a href="#Performance">
        Performance</a> for details. – <strong>Note:</strong> This property is 
      available in Hashtable.cst for consistency but has no effect in that template 
      file.</p>
    <p><em>ItemCustomSearch</em> – an optional Boolean value that defaults to <code>false</code>. 
      If set to <code>true</code>, this property indicates that <em>ItemType</em> searches 
      should be handled by custom routines instead of System.Array methods. Please 
      refer to <a href="#Performance">Performance</a> for details. – <strong>Note:</strong>
      This property is available in Hashtable.cst and Queue.cst for consistency but 
      has no effect in these template files.</p>
    <h3>
      <a name="ArrayList">4.2 ArrayList.cst</a></h3>
    <p>This class is a strongly typed reimplementation of the standard ArrayList. 
      Type casting occurs only when the collection is accessed through generic 
      interfaces. As of version 1.4.1, ArrayList.cst offers two additional 
      non-standard features:</p>
    <ul>
      <li>
        <p>A “unique” wrapper, in addition to the read-only and synchronized wrappers. 
          This wrapper ensures that the collection contains no duplicate elements.</p>
      </li>
      <li>
        <p>An optional “key” that refers to one of the fields or properties of the <em>ItemType</em>
          class. Three new methods – ContainsKey, GetByKey, and IndexOfKey – and an 
          optional indexer locate collection elements by their “key” value.</p>
      </li>
    </ul>
    <h4>Additional Properties</h4>
    <p><em>ClassName</em> – an optional string that defaults to “<em>ItemType</em>Collection”. 
      This property determines the name of the generated collection class.</p>
    <p><em>ItemType</em> – a required string that defaults to a null reference. This 
      property determines the element type of the generated collection class.</p>
    <p><em>KeyType</em> – an optional string that defaults to a null reference. If 
      provided, this property determines the type of the <em>ItemType</em> field or 
      property to use as a “key” when locating collection elements.</p>
    <p><em>KeyName</em> – an optional string that defaults to “<em>KeyType</em>”. If 
      provided, this property determines the name of the <em>ItemType</em> field or 
      property to use as a “key” when locating collection elements.</p>
    <p><em>KeyIndexer</em> – an optional Boolean value that defaults to <code>false</code>. 
      If set to <code>true</code>, this property indicates that a <em>KeyType</em> indexer 
      should be generated. – <strong>Note:</strong> This will result in a compilation 
      error if <em>KeyType</em> is Int32, and possibly cause unwanted implicit type 
      conversions if <em>KeyType</em> is another numerical type.</p>
    <h4>Required Templates</h4>
    <p>An instance of <a href="#IList">IList.cst</a> with sufficient <em>Accessibility</em>
      and otherwise identical property values.</p>
    <h4>Generated Classes</h4>
    <p><em>ClassName</em> – an ArrayList that is strongly typed for <em>ItemType</em> 
      elements. This class implements ICloneable, ICollection, IList, I<em>ItemType</em>Collection, 
      and I<em>ItemType</em>List. The GetEnumerator method returns an I<em>ItemType</em>Enumerator.</p>
    <h4>Default File Name</h4>
    <p>The default name for the generated C# source file is “<em>ClassName</em>.cs”.</p>
    <h3>
      <a name="DictionaryList">4.3 DictionaryList.cst</a></h3>
    <p>This class is my own invention. A generic version is available as part of the <a href="http://www.kynosarges.de/Toolbox.html">
        Toolbox .NET</a> library. It’s basically an ArrayList that is strongly typed 
      for DictionaryEntry elements and can therefore support a number of SortedList 
      features. Unlike the SortedList class, a DictionaryList can hold multiple 
      identical keys and always maintains the insertion order of its elements. On the 
      downside, access by key is just as slow as access by value (linear time).</p>
    <p>As with all other collection classes except for <a href="#Hashtable">Hashtable</a>, 
      type casting occurs only when the collection is accessed through generic 
      interfaces.</p>
    <h4>Additional Properties</h4>
    <p><em>ClassName</em> – an optional string that defaults to “<em>KeyType</em><em>ItemType</em>Collection”. 
      This property determines the name of the generated collection class.</p>
    <p><em>ImportNamespace</em> – an optional string that defaults to a null 
      reference. If provided, this property determines the namespace in which one of 
      the required IList interfaces resides. This namespace will be imported by a <code>
        using</code> statement if <em>IncludeNamespaces</em> is <code>true</code>.</p>
    <p><em>KeyType</em> – a required string that defaults to a null reference. This 
      property determines the type of the Key parts of the generated collection 
      class.</p>
    <p><em>ItemType</em> – a required string that defaults to a null reference. This 
      property determines the type of the Value parts of the generated collection 
      class.</p>
    <p><em>PairType</em> – an optional string that defaults to “<em>KeyType</em><em>ItemType</em>Entry”. 
      This property determines the name of the pair structure provided by the 
      required IDictionary template.</p>
    <h4>Required Templates</h4>
    <p>An instance of <a href="#IDictionary">IDictionary.cst</a> with sufficient <em>Accessibility</em>
      and otherwise identical property values.</p>
    <h4>Generated Classes</h4>
    <p><em>ClassName</em> – a DictionaryList that is strongly typed for <em>PairType</em>
      elements, <em>KeyType</em> keys, and <em>ItemType</em> values. This class 
      implements ICloneable, ICollection, IList, I<em>KeyType</em><em>ItemType</em>Collection, 
      and I<em>KeyType</em><em>ItemType</em>List. The GetEnumerator method returns an 
      I<em>KeyType</em><em>ItemType</em>Enumerator.</p>
    <p>The Keys property of <em>ClassName</em> returns an I<em>KeyType</em>Collection, 
      the GetKeyList method returns an I<em>KeyType</em>List, and the GetEnumerator 
      method of either collection returns an I<em>KeyType</em>Enumerator.</p>
    <p>The Values property of <em>ClassName</em> returns an I<em>ItemType</em>Collection, 
      the GetValueList method returns an I<em>ItemType</em>List, and the 
      GetEnumerator method of either collection returns an I<em>ItemType</em>Enumerator.</p>
    <h4>Default File Name</h4>
    <p>The default name for the generated C# source file is “<em>ClassName</em>.cs”.</p>
    <h3>
      <a name="Hashtable">4.4 Hashtable.cst</a></h3>
    <p>This class is just a wrapper around the standard Hashtable, rather than a 
      complete reimplementation. So when you use value types you should expect plenty 
      of boxing and unboxing going on internally, even though it is hidden by the 
      strongly typed wrapper, and performance is likely to be poor.</p>
    <p>As of version 1.5.0, Hashtable.cst offers a read-only wrapper as an additional 
      non-standard feature.</p>
    <h4>Additional Properties</h4>
    <p><em>ClassName</em> – an optional string that defaults to “<em>KeyType</em><em>ItemType</em>Dictionary”. 
      This property determines the name of the generated collection class.</p>
    <p><em>ImportNamespace</em> – an optional string that defaults to a null 
      reference. If provided, this property determines the namespace in which one of 
      the required IList interfaces resides. This namespace will be imported by a <code>
        using</code> statement if <em>IncludeNamespaces</em> is <code>true</code>.</p>
    <p><em>KeyType</em> – a required string that defaults to a null reference. This 
      property determines the type of the Key parts of the generated collection 
      class.</p>
    <p><em>ItemType</em> – a required string that defaults to a null reference. This 
      property determines the type of the Value parts of the generated collection 
      class.</p>
    <p><em>PairType</em> – an optional string that defaults to “<em>KeyType</em><em>ItemType</em>Entry”. 
      This property determines the name of the pair structure provided by the 
      required IDictionary template.</p>
    <h4>Required Templates</h4>
    <p>An instance of <a href="#IDictionary">IDictionary.cst</a> with sufficient <em>Accessibility</em>
      and otherwise identical property values.</p>
    <h4>Generated Classes</h4>
    <p><em>ClassName</em> – a Hashtable that is strongly typed for <em>PairType</em> elements,
      <em>KeyType</em> keys, and <em>ItemType</em> values. This class implements 
      ICloneable, ICollection, IDictionary, I<em>KeyType</em><em>ItemType</em>Collection, 
      and I<em>KeyType</em><em>ItemType</em>Dictionary. The GetEnumerator method 
      returns an I<em>KeyType</em><em>ItemType</em>Enumerator.</p>
    <p>The Keys property of <em>ClassName</em> returns an I<em>KeyType</em>Collection 
      whose GetEnumerator method returns an I<em>KeyType</em>Enumerator.</p>
    <p>The Values property of <em>ClassName</em> returns an I<em>ItemType</em>Collection 
      whose GetEnumerator method returns an I<em>ItemType</em>Enumerator.</p>
    <h4>Default File Name</h4>
    <p>The default name for the generated C# source file is “<em>ClassName</em>.cs”.</p>
    <h3>
      <a name="IDictionary">4.5 IDictionary.cst</a></h3>
    <p>This file contains a collection of strongly typed interfaces required for all 
      collections that store key-and-value pairs. It also includes the strongly typed 
      pair structure itself.</p>
    <h4>Additional Properties</h4>
    <p><em>ImportNamespace</em> – an optional string that defaults to a null 
      reference. If provided, this property determines the namespace in which one of 
      the required IList interfaces resides. This namespace will be imported by a <code>
        using</code> statement if <em>IncludeNamespaces</em> is <code>true</code>.</p>
    <p><em>KeyType</em> – a required string that defaults to a null reference. This 
      property determines the type of the Key parts of the generated dictionary 
      types.</p>
    <p><em>ItemType</em> – a required string that defaults to a null reference. This 
      property determines the type of the Value parts of the generated dictionary 
      types.</p>
    <p><em>PairType</em> – an optional string that defaults to “<em>KeyType</em><em>ItemType</em>Entry”. 
      This property determines the name of the generated pair structure.</p>
    <h4>Required Templates</h4>
    <p>Two instances of <a href="#IList">IList.cst</a> with sufficient <em>Accessibility</em>.</p>
    <p>One instance must use identical <em>ItemType</em>, <em>ItemNamespace</em>, and <em>
        ItemValueType</em> properties. The other instance must use <em>ItemType</em>, <em>
        ItemNamespace</em>, and <em>ItemValueType</em> properties that are identical 
      to the <em>KeyType</em>, <em>KeyNamespace</em>, and <em>KeyValueType</em> properties, 
      respectively, of the IDictionary template.</p>
    <p>At least one instance must use an identical <em>TargetNamespace</em> property. 
      If the other instance uses a different <em>TargetNamespace</em>, the <em>ImportNamespace</em>
      property must be set to that namespace.</p>
    <h4>Generated Interfaces</h4>
    <p>I<em>KeyType</em><em>ItemType</em>Collection – an ICollection that is strongly 
      typed for <em>PairType</em> elements.</p>
    <p>I<em>KeyType</em><em>ItemType</em>Dictionary – an IDictionary that is strongly 
      typed for <em>PairType</em> elements, <em>KeyType</em> keys, and <em>ItemType</em>
      values. This interface is implemented by <a href="#Hashtable">Hashtable.cst</a> 
      and <a href="#SortedList">SortedList.cst</a>.</p>
    <p>I<em>KeyType</em><em>ItemType</em>List – an IList that is strongly typed for <em>
        PairType</em> elements. This interface is implemented by <a href="#DictionaryList">
        DictionaryList.cst</a>.</p>
    <p>I<em>KeyType</em><em>ItemType</em>Enumerator – an IEnumerator that is strongly 
      typed for <em>PairType</em> elements, <em>KeyType</em> keys, and <em>ItemType</em>
      values.</p>
    <h4>Generated Structures</h4>
    <p><em>PairType</em> – a DictionaryEntry that is strongly typed for <em>KeyType</em>
      keys and <em>ItemType</em> values. This structure provides implicit conversions 
      to and from DictionaryEntry objects.</p>
    <h4>Default File Name</h4>
    <p>The default name for the generated C# source file is “I<em>KeyType</em><em>ItemType</em>Dictionary.cs”.</p>
    <h3>
      <a name="IList">4.6 IList.cst</a></h3>
    <p>This file contains a collection of strongly typed interfaces required for all 
      other interfaces and collections in this package.</p>
    <h4>Additional Properties</h4>
    <p><em>ItemType</em> – a required string that defaults to a null reference. This 
      property determines the element type of all generated collection interfaces.</p>
    <h4>Required Templates</h4>
    <p>None.</p>
    <h4>Generated Interfaces</h4>
    <p>I<em>ItemType</em>Collection – an ICollection that is strongly typed for <em>ItemType</em>
      elements.</p>
    <p>I<em>ItemType</em>List – an IList that is strongly typed for <em>ItemType</em> 
      elements.</p>
    <p>I<em>ItemType</em>Enumerator – an IEnumerator that is strongly typed for <em>ItemType</em>
      elements.</p>
    <h4>Default File Name</h4>
    <p>The default name for the generated C# source file is “I<em>ItemType</em>List.cs”.</p>
    <h3>
      <a name="Queue">4.7 Queue.cst</a></h3>
    <p>This class is a strongly typed reimplementation of the standard Queue. Type 
      casting occurs only when the collection is accessed through generic interfaces.</p>
    <h4>Additional Properties</h4>
    <p><em>ClassName</em> – an optional string that defaults to “<em>ItemType</em>Queue”. 
      This property determines the name of the generated collection class.</p>
    <p><em>ItemType</em> – a required string that defaults to a null reference. This 
      property determines the element type of the generated collection class.</p>
    <h4>Required Templates</h4>
    <p>An instance of <a href="#IList">IList.cst</a> with sufficient <em>Accessibility</em>
      and otherwise identical property values.</p>
    <h4>Generated Classes</h4>
    <p><em>ClassName</em> – a Queue that is strongly typed for <em>ItemType</em> elements. 
      This class implements ICloneable, ICollection, and I<em>ItemType</em>Collection. 
      The GetEnumerator method returns an I<em>ItemType</em>Enumerator.</p>
    <h4>Default File Name</h4>
    <p>The default name for the generated C# source file is “<em>ClassName</em>.cs”.</p>
    <h3>
      <a name="SortedList">4.8 SortedList.cst</a></h3>
    <p>This class is a strongly typed reimplementation of the standard SortedList. 
      Type casting occurs only when the collection is accessed through generic 
      interfaces.</p>
    <h4>Additional Properties</h4>
    <p><em>ClassName</em> – an optional string that defaults to “<em>KeyType</em><em>ItemType</em>Dictionary”. 
      This property determines the name of the generated collection class.</p>
    <p><em>ImportNamespace</em> – an optional string that defaults to a null 
      reference. If provided, this property determines the namespace in which one of 
      the required IList interfaces resides. This namespace will be imported by a <code>
        using</code> statement if <em>IncludeNamespaces</em> is <code>true</code>.</p>
    <p><em>KeyType</em> – a required string that defaults to a null reference. This 
      property determines the type of the Key parts of the generated collection 
      class.</p>
    <p><em>ItemType</em> – a required string that defaults to a null reference. This 
      property determines the type of the Value parts of the generated collection 
      class.</p>
    <p><em>PairType</em> – an optional string that defaults to “<em>KeyType</em><em>ItemType</em>Entry”. 
      This property determines the name of the pair structure provided by the 
      required IDictionary template.</p>
    <h4>Required Templates</h4>
    <p>An instance of <a href="#IDictionary">IDictionary.cst</a> with sufficient <em>Accessibility</em>
      and otherwise identical property values.</p>
    <h4>Generated Classes</h4>
    <p><em>ClassName</em> – a SortedList that is strongly typed for <em>PairType</em> 
      elements, <em>KeyType</em> keys, and <em>ItemType</em> values. This class 
      implements ICloneable, ICollection, IDictionary, I<em>KeyType</em><em>ItemType</em>Collection, 
      and I<em>KeyType</em><em>ItemType</em>Dictionary. The GetEnumerator method 
      returns an I<em>KeyType</em><em>ItemType</em>Enumerator.</p>
    <p>The Keys property of <em>ClassName</em> returns an I<em>KeyType</em>Collection, 
      the GetKeyList method returns an I<em>KeyType</em>List, and the GetEnumerator 
      method of either collection returns an I<em>KeyType</em>Enumerator.</p>
    <p>The Values property of <em>ClassName</em> returns an I<em>ItemType</em>Collection, 
      the GetValueList method returns an I<em>ItemType</em>List, and the 
      GetEnumerator method of either collection returns an I<em>ItemType</em>Enumerator.</p>
    <h4>Default File Name</h4>
    <p>The default name for the generated C# source file is “<em>ClassName</em>.cs”.</p>
    <h3>
      <a name="Stack">4.9 Stack.cst</a></h3>
    <p>This class is a strongly typed reimplementation of the standard Stack. Type 
      casting occurs only when the collection is accessed through generic interfaces.</p>
    <h4>Additional Properties</h4>
    <p><em>ClassName</em> – an optional string that defaults to “<em>ItemType</em>Stack”. 
      This property determines the name of the generated collection class.</p>
    <p><em>ItemType</em> – a required string that defaults to a null reference. This 
      property determines the element type of the generated collection class.</p>
    <h4>Required Templates</h4>
    <p>An instance of <a href="#IList">IList.cst</a> with sufficient <em>Accessibility</em>
      and otherwise identical property values.</p>
    <h4>Generated Classes</h4>
    <p><em>ClassName</em> – a Stack that is strongly typed for <em>ItemType</em> elements. 
      This class implements ICloneable, ICollection, and I<em>ItemType</em>Collection. 
      The GetEnumerator method returns an I<em>ItemType</em>Enumerator.</p>
    <h4>Default File Name</h4>
    <p>The default name for the generated C# source file is “<em>ClassName</em>.cs”.</p>
    <h2><a name="Performance">5. Performance</a></h2>
    <p>The following discussion applies to all collection templates except 
      Hashtable.cst which is simply a strongly typed wrapper around the standard 
      Hashtable and therefore performs the same or slightly worse than the standard 
      library class.</p>
    <h3>5.1 Technical Issues</h3>
    <p>The collection templates are algorithmically identical to the standard 
      collection classes. The only difference is the fact that the template classes 
      are strongly typed and therefore require no type casting, unless accessed 
      through generic interfaces. This may cause a template collection to perform 
      significantly better than a standard collection, depending on the collection’s 
      element type(s).</p>
    <p>There is another, more obscure influence on the performance of a .NET 
      collection for a given type, namely the static methods of the System.Array 
      class. We’ll first discuss these technical issues before moving on to 
      performance recommendations. A table of benchmark results concludes this 
      section.</p>
    <h4>Type Conversions</h4>
    <p>Type conversion between <strong>reference types</strong> is extremely fast in 
      the .NET Framework. Strong typing may yield a small performance gain that will 
      hardly matter in a real application. The only important benefit gained from 
      collection templates with reference type elements is compile-time type checking 
      (and more helpful IntelliSense suggestions if you’re using Visual Studio .NET).</p>
    <p>Type conversion from <strong>value types</strong> to reference types and vice 
      versa involves expensive operations known as “boxing” and “unboxing”, 
      respectively. The standard collection classes perform lots of these operations 
      because they are written for elements of type System.Object – a reference type. 
      Strong typing completely avoids these operations which may improve benchmark 
      performance by an order of magnitude. Any application that makes heavy use of 
      value type collections should see a significant speedup after converting to 
      collection templates.</p>
    <h4>Static Array Methods</h4>
    <p>The collection templates and the standard collection classes both rely on 
      static methods of the System.Array class to quickly and conveniently manipulate 
      one-dimensional arrays: Clear, BinarySearch, Copy, IndexOf, Reverse, and Sort.</p>
    <p>All of these methods invoke native code routines for maximum performance. 
      However, the BinarySearch, IndexOf, Reverse, and Sort methods may fall back on 
      generic IL routines if the native routine returns an error. This appears to be 
      the case whenever the array elements are not of a built-in value type, such as 
      System.Int32.</p>
    <p>The generic IL routines treat all array elements as instances of System.Object 
      and use the standard methods Object.Equals and IComparable.CompareTo to compare 
      elements. This results in a small overhead for reference types that offer 
      strongly typed implementations of these comparison methods, and a very large 
      overhead for user-defined value types which have to be boxed for every single 
      comparison.</p>
    <h4>Custom Search Routines</h4>
    <p>To avoid this overhead, all class templates offer the <em>ItemCustomSearch</em>
      and possibly <em>KeyCustomSearch</em> properties that will replace all 
      Array.BinarySearch and Array.IndexOf calls with a strongly typed C# 
      reimplementation of the corresponding search algorithm. (There is currently no 
      reimplementation of Array.Reverse and Array.Sort.)</p>
    <p>Custom search routines are disabled by default to accomodate built-in value 
      types. They are better handled by native code routines anyway; but on top of 
      that, these types surprisingly do not offer strongly typed overloads of 
      Object.Equals and IComparable.CompareTo which would cause the C# 
      reimplementations to perform countless boxing operations.</p>
    <p>(Using comparison operators instead of methods would have solved this problem 
      for built-in value types but would in turn require all custom types to define 
      all required operators before they could be used with the custom search 
      routines.)</p>
    <h3>5.2 Recommendations</h3>
    <p>Any user-defined <em>KeyType</em> or <em>ItemType</em> should provide strongly 
      typed overloads of Object.Equals, and also IComparable.CompareTo for <em>KeyType</em>
      classes, to avoid type casting as much as possible. This is necessary to fully 
      realize the potential performance benefits of <em>KeyCustomSearch</em> and <em>ItemCustomSearch</em>.</p>
    <h4>Reference Types</h4>
    <p>Type conversion between reference types is extremely fast, so the runtime 
      performance of template classes is roughly identical to that of standard 
      library classes in this case. Setting the <em>KeyCustomSearch</em> and/or <em>ItemCustomSearch</em>
      properties to <code>true</code> will result in a small performance gain. It 
      doesn’t matter if the reference type is provided by the standard library or 
      defined by the user.</p>
    <h4>Standard Value Types</h4>
    <p>Boxing and unboxing is expensive, but the native code routines provided by the 
      standard library outperform any C# reimplementation. Just set the <em>KeyValueType</em>
      and/or <em>ItemValueType</em> properties to <code>true</code> as appropriate. 
      Do <strong>not</strong> set the <em>KeyCustomSearch</em> and/or <em>ItemCustomSearch</em>
      properties to <code>true</code>, or performance will collapse!</p>
    <h4>Custom Value Types</h4>
    <p>As above, except that there are no native code routines that we could use. Set 
      the <em>KeyValueType</em> and/or <em>ItemValueType</em> properties <strong>and</strong>
      the corresponding <em>KeyCustomSearch</em> and <em>ItemCustomSearch</em> properties 
      to <code>true</code> for maximum performance.</p>
    <h3>5.3 Benchmark Results</h3>
    <p>This section shows the benchmark results I’ve obtained on my system for 
      several different ways to represent a simple collection of items.</p>
    <ul>
      <li>
        <p><strong>String</strong> is the reference type System.String and represents 
          performance for all kinds of reference type.</p>
      <li>
        <p><strong>Int32</strong> is the built-in value type System.Int32 and represents 
          performance for value types that enjoy special support by the C# compiler and 
          the .NET Framework.</p>
      <li>
        <p><strong>ValidString</strong> is the value type Toolbox.StringTbx.ValidString 
          which is a simple wrapper around System.String provided by version 2.0.3 of my <a href="http://www.kynosarges.de/Toolbox.hml">
            Toolbox .NET</a> library. ValidString represents performance for value types 
          that do not enjoy any special compiler or Framework support.</p>
      </li>
    </ul>
    <p>For each item type, I tested three collection classes: the standard library 
      ArrayList, a standard fixed-size array, and a collection class generated by the 
      ArrayList.cst template that shipped with version 1.2.0 of the Collection 
      Templates package. Each timed section consists of the following actions:</p>
    <ol>
      <li>
      Call Add to add the specified number of (random) elements to the empty 
      collection. For fixed arrays, we simply set each array element to the desired 
      value.
      <li>
      Call IndexOf to determine the index of each collection element.
      <li>
      Call Sort to sort the collection, and then call BinarySearch to determine the 
      index of each collection element.
      <li>
      Use a foreach loop to call GetEnumerator and iterate over all collection 
      elements.
      <li>
        Call RemoveAt to remove all elements from the collection, starting at the 
        highest index. For fixed arrays, we simply set each array element to a null or 
        zero value.</li>
    </ol>
    <p>The tests were run in release mode with optimization enabled. Fast dummy 
      operations (integer exclusive-or) were performed in each loop to prevent the C# 
      or JIT compiler from “optimizing away” the instructions we’re interested in. 
      The results showed little deviation in dozens of repetitions.</p>
    <p>Times are given in seconds, and as an inverse percentage compared to 
      ArrayList. Timing was performed by <a href="http://www.csunit.org">csUnit 1.8.8</a>
      which was also used to unit-test the collection templates. Benchmark and unit 
      testing sources are available on request.</p>
    <table border="1">
      <tr>
        <th>
          Items</th>
        <th>
          Count</th>
        <th colspan="2">
          ArrayList</th>
        <th colspan="2">
          Fixed Array</th>
        <th colspan="2">
          Template</th>
      </tr>
      <tr>
        <td>String</td>
        <td align="right">25,000</td>
        <td align="right">11.547 sec</td>
        <td align="right">100%</td>
        <td align="right">11.500 sec</td>
        <td align="right">100%</td>
        <td align="right">10.250 sec</td>
        <td align="right">113%</td>
      </tr>
      <tr>
        <td>Int32</td>
        <td align="right">50,000</td>
        <td align="right">36.656 sec</td>
        <td align="right">100%</td>
        <td align="right">2.375 sec</td>
        <td align="right">1543%</td>
        <td align="right">2.406 sec</td>
        <td align="right">1524%</td>
      </tr>
      <tr>
        <td>ValidString</td>
        <td align="right">10,000</td>
        <td align="right">6.250 sec</td>
        <td align="right">100%</td>
        <td align="right">16.938 sec</td>
        <td align="right">36.9%</td>
        <td align="right">1.969 sec</td>
        <td align="right">317%</td>
      </tr>
    </table>
    <h4>Observations</h4>
    <p>The template class always performs at least as well as the faster of the two 
      standard classes, ArrayList or fixed array. It is interesting to note that the 
      memory reallocations which are required for ArrayList and ArrayList.cst, but 
      not for fixed arrays, do not seem to impact performance at all.</p>
    <p><strong>String.</strong> As expected, all three classes perform about the 
      same. System.String offers a CompareTo method (even a strongly typed one) which 
      allows the use of custom search routines, resulting in a small performance edge 
      for the template class.</p>
    <p><strong>Int32.</strong> Frequent boxing and unboxing causes extremely poor 
      performance for the standard ArrayList. The fixed array and the template class 
      both avoid this problem and perform equally well.</p>
    <p><strong>ValidString.</strong> Performance is again much better for the 
      template class than for the standard ArrayList which is bogged down by 
      boxing/unboxing operations. Surprisingly, ArrayList performs <em>better</em> than 
      a fixed array in this case. This is likely because ArrayList already stores its 
      elements in “boxed” format, thus saving some time when the static Array methods 
      fall back on their generic search routines.</p>
    <h2><a name="History">6. Version History</a></h2>
    <table border="1">
      <tbody>
        <tr>
          <th width="120">
            Released</th>
          <th width="100">
            Version</th>
          <th>
            Description</th>
        </tr>
        <tr>
          <td align="center">2004-03-01</td>
          <td align="center">1.5.0</td>
          <td nowrap>Added template file Queue.cst<br>
            Added <em>DeepCopy</em> and <em>DeepCopyItem</em> properties to class templates<br>
            Moved <em>ItemValueType</em> and <em>KeyValueType</em> to Context group<br>
            Moved common script methods to separate file CommonScript.cs<br>
            DictionaryList, SortedList: Clone duplicates synchronized wrappers<br>
            DictionaryList, SortedList: Devirtualized Contains… methods<br>
            Hashtable: Added ReadOnly wrapper, fixed CopyTo method<br>
            Stack: Pop correctly clears reference to deleted element<br>
          </td>
        </tr>
        <tr>
          <td align="center">2004-01-19</td>
          <td align="center">1.4.1</td>
          <td nowrap>ArrayList: Added IsUnique property and Unique method,<br>
            &nbsp;&nbsp;based on a post by Joost in the CodeSmith forums<br>
            ArrayList: Added <em>KeyName, KeyType,</em> and <em>KeyIndexer</em><br>
            &nbsp;&nbsp;properties, with corresponding indexer and methods<br>
            ArrayList: Devirtualized Contains and ContainsKey methods<br>
          </td>
        </tr>
        <tr>
          <td align="center">2003-12-22</td>
          <td align="center">1.4.0</td>
          <td nowrap>ArrayList: Added InnerArray to fix AddRange(<em>ClassName</em>)<br>
            &nbsp;&nbsp;for read-only and synchronized wrappers<br>
            DictionaryList: Added InnerKeys/Values to fix
            <br>
            &nbsp;&nbsp;AddRange(<em>ClassName</em>) and Equals for synchronized wrapper<br>
            Fixed <em>Accessibility</em> propagation if <em>IncludeInterfaces</em> is <code>true</code><br>
            Namespaces are always declared if <em>IncludeNamespaces</em> is <code>true</code>,<br>
            &nbsp;&nbsp;even when re-instantiating the same compiled template<br>
          </td>
        </tr>
        <tr>
          <td align="center">2003-11-21</td>
          <td align="center">1.3.2</td>
          <td nowrap>Added default output file names to all templates</td>
        </tr>
        <tr>
          <td align="center">2003-11-02</td>
          <td align="center">1.3.1</td>
          <td nowrap>ArrayList: Added methods Reverse(), Reverse(Int32, Int32),<br>
            &nbsp;&nbsp;Sort(IComparer), and Sort(Int32, Int32, IComparer)</td>
        </tr>
        <tr>
          <td align="center">2003-10-09</td>
          <td align="center">1.3.0</td>
          <td nowrap>Added <em>IncludeInterfaces</em> and <em>IncludeNamespaces</em> properties<br>
            Changed IList.Item (DictionaryList) and IEnumerator.Current<br>
            &nbsp;&nbsp;(DictionaryList, SortedList) to return boxed DictionaryEntry<br>
            Revised overview and tutorial sections of ReadMe file</td>
        </tr>
        <tr>
          <td align="center">2003-09-28</td>
          <td align="center">1.2.3</td>
          <td nowrap>Added #region directives for overloads and private methods/classes<br>
            Added line breaks as necessary, removed all trailing whitespace</td>
        </tr>
        <tr>
          <td align="center">2003-08-03</td>
          <td align="center">1.2.2</td>
          <td nowrap>Eliminated duplicate namespace imports (thanks to Ben Mackie!)<br>
            Added script methods Start/EndNamespace to all templates<br>
            IDictionary.I<em>KeyItem</em>Enumerator.Entry: Fixed XML comment</td>
        </tr>
        <tr>
          <td align="center">2003-07-24</td>
          <td align="center">1.2.1</td>
          <td nowrap>Added documented version checking to all enumerator properties</td>
        </tr>
        <tr>
          <td align="center">2003-06-24</td>
          <td align="center">1.2.0</td>
          <td nowrap>Added properties <em>ItemCustomSearch</em> and <em>KeyCustomSearch</em><br>
            Added object casts for null comparisons of <em>KeyType</em> and <em>ItemType</em><br>
            Added section on performance considerations to ReadMe file<br>
            ArrayList.AddRange: Fixed premature capacity increase<br>
            ArrayList.BinarySearch: This method actually works now…<br>
            ArrayList: Added method RemoveRange<br>
            DictionaryList.AddRange: Fixed premature capacity increase<br>
            Stack: Inverted direction of CopyTo, GetEnumerator, and ToArray</td>
        </tr>
        <tr>
          <td align="center">2003-06-16</td>
          <td align="center">1.1.0</td>
          <td nowrap>Added template file Stack.cst</td>
        </tr>
        <tr>
          <td align="center">2003-06-11</td>
          <td align="center">1.0.1</td>
          <td nowrap>ArrayList, DictionaryList, SortedList: Fixed null reference exceptions</td>
        </tr>
        <tr>
          <td align="center">2003-06-10</td>
          <td align="center">1.0.0</td>
          <td nowrap>Initial release of Collection Templates</td>
        </tr>
      </tbody>
    </table>
    <h2><a name="Issues">7. Known Issues</a></h2>
    <p>If <em>IncludeInterfaces</em> is set to <code>true</code>, all required 
      interface template files must be in the same directory as the parent template. 
      By default all template files are unpacked to the same directory, so this is 
      only an issue if you have deliberately placed some template files in a 
      different directory.</p>
    <p>If defined, <em>KeyNamespace</em> and <em>ItemNamespace</em> are imported with <code>
        using</code> statements. All dictionary templates therefore require that <em>KeyType</em>
      and <em>ItemType</em> have different names; it is not sufficient that they 
      reside in in different namespaces.</p>
    <p>The enumerator properties Current, Entry, Key, and Value should buffer their 
      return values and ignore changes to the underlying collection until the next 
      call to MoveNext or Reset. However, all collection templates except 
      Hashtable.cst use simpler implementations without buffering that fail when the 
      underlying collection was changed. This should not be a problem with typical <code>
        foreach</code> loops; and in my opinion, it’s also the behavior one would 
      intuitively except.</p>
    <p>If <em>KeyCustomSearch</em> or <em>ItemCustomSearch</em> are <code>false</code>, 
      the standard BinarySearch routines will explicitly request the interface method 
      IComparable.CompareTo and ignore any non-interface method of the same name. 
      Conversely, when these properties are <code>true</code>, the custom 
      BinarySearch routines will attempt to directly invoke CompareTo on a <em>KeyType</em>
      or <em>ItemType</em> object. Therefore, these routines will not compile if the 
      only available CompareTo method is an explicit interface implementation of 
      IComparable. – Note that the usual and recommended case is an implicit (public) 
      implementation of CompareTo which will work fine with either property setting.</p>
    <p>ArrayList: <em>ItemType</em> must define a CompareTo method if <em>ItemCustomSearch</em>
      is <code>true</code>, or the custom BinarySearch method won’t compile. Set <em>ItemCustomSearch</em>
      to <code>false</code> if your <em>ItemType</em> does not provide a CompareTo 
      method, or add a mock CompareTo method to <em>ItemType</em> if you don’t need 
      BinarySearch.</p>
    <p>ArrayList: If <em>KeyType</em> is defined, the generated key indexer (if any) 
      and the ContainsKey, GetByKey, and IndexOfKey methods use the == operator of 
      the <em>KeyType</em> class, so make sure to properly define this operator if 
      you override Object.Equals for this class.</p>
    <p>DictionaryList: The methods Contains, Equals, and IndexOf use the == and != 
      operators of the <em>KeyType</em> and <em>ItemType</em> classes, so make sure 
      to properly define these operators if you override Object.Equals for either 
      class.</p>
  </body>
</html>
