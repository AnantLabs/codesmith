<%-- 
Name: BL Base Class Template
Author: Chris Lasater
Description: Allows generation of BL Base class from parameters
--%>
<%@ CodeTemplate Language="C#" TargetLanguage="C#" Src="../../../Utility/ProjectHelper.cs" Inherits="Utility.ProjectHelper" Description="Single Record Concrete Class Template" %>

<%@ Assembly Name="SchemaExplorer" %>
<%@ Import Namespace="SchemaExplorer" %>

using System;
using System.Collections;
using System.Data;

//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by APOSA CodeSmith Domain Object Template.
//
//     Date:    <%= DateTime.Now.ToString("M/d/yyyy") %>
//     Time:    <%= DateTime.Now.ToString("h:mm tt") %>
//     Version: <%= typeof(CodeTemplate).Assembly.GetName().Version.ToString() %>
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace <%= CompanyNameSpace %>.<%=ProjectNameSpace%>.BusinessLayer.Base.Collections
{
    /// <summary>
    /// This class is the implementation class for the interface
    /// it houses all data push pull functionality
    /// THis is a colection object which acts as an iterator, and the interface ISearchResultsBL
    /// makes sure it gets ILIst implemented for UI databinding
    /// it is marked internal so it cannot be created outside the 
    /// assembly, this makes sure only expected creations of the oobject are possible
    /// and makes the assembly into a complete facade with only known interfaces as entry points
    /// </summary>
    [Serializable]
    internal abstract class CollectionsBase : BLBase, <%= CompanyNameSpace %>.<%=ProjectNameSpace%>.BusinessLayer.Base.IBLBase, IEnumerator, IList,
        System.ComponentModel.IListSource, System.Runtime.Serialization.ISerializable
    {
        #region Private Variables
        private int _index = 0;
        private ArrayList _pageSetResults = new ArrayList();
        private ArrayList _allResults = new ArrayList();
        #endregion

        #region Constructor
        /// <summary>
        /// Generic Constructor for Collections BL
        /// </summary>
        /// <param name="connectionString"></param>
        public CollectionsBase()
        {

        }
        /// <summary>
        /// This is used to create the object from serialization data
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        public CollectionsBase(System.Runtime.Serialization.SerializationInfo info,
            System.Runtime.Serialization.StreamingContext context)
            : this()
        {
            this.AllResults = (ArrayList)info.GetValue("AllResults", typeof(ArrayList));
            this.PageSetResults = (ArrayList)info.GetValue("PageSetResults", typeof(ArrayList));
        }
        #endregion

        #region Protected Properties
        /// <summary>
        /// used by inheriting classes to fill data from inside the assembly
        /// </summary>
        protected internal ArrayList AllResults
        {
            get { return _allResults; }
            set { _allResults = value; }
        }
        /// <summary>
        /// used to get a page set of data from within the assembly
        /// </summary>
        protected internal ArrayList PageSetResults
        {
            get { return _pageSetResults; }
            set { _pageSetResults = value; }
        }

        #endregion

        #region Record Paging Methods
        /// <summary>
        /// Allows overriding to deal with lazy load of just the page set data.
        /// Returns a sub set of the internal data
        /// </summary>
        /// <param name="pageNumber"></param>
        /// <param name="pageSize"></param>
        /// <returns></returns>
        public virtual void GetNextPageSet(int pageNumber, int pageSize)
        {

            int start = (pageNumber < 1 ? 0 : pageNumber - 1) * (pageSize + 1);
            _pageSetResults.Clear();

            if (start < this._allResults.Count)
            {
                if (start + pageSize <= this._allResults.Count)
                    _pageSetResults.AddRange(_allResults.GetRange(start, pageSize));
                else
                {
                    for (int i = start; i < this._allResults.Count; i++)
                        _pageSetResults.Add(this._allResults[i]);
                }

            }

        }
        #endregion

        #region Public Methods       
        /// <summary>
        /// no-op on this class
        /// </summary>
        public void SaveData() { }
        #endregion

        #region All Records Methods
        /// <summary>
        /// Count of all records in underlying collection
        /// </summary>
        public int TotalRecordCount
        {
            get
            {
                return this._allResults.Count;
            }
        }

        #endregion

        #region Indexer
        public object this[int index]
        {
            get
            {
                return this._pageSetResults[index];
            }
            set
            {
                this._pageSetResults[index] = value;
            }
        }

        #endregion

        #region IEnumerator Members
        /// <summary>
        /// Resets the index for the iterator
        /// </summary>
        public void Reset()
        {
            _index = 0;
        }
        /// <summary>
        /// Return the current object at its index
        /// </summary>
        public object Current
        {
            get
            {
                return this[_index];
            }
        }
        /// <summary>
        /// Moves the index to the next position in the iterator, 
        /// if the index does not exceed the count. Proper use of this method 
        /// would include a check for EOF
        /// </summary>
        /// <returns></returns>
        public bool MoveNext()
        {
            if (_index + 1 < _pageSetResults.Count)
            {
                _index++;
                return true;
            }
            return false;
        }

        #endregion

        #region IList Members

        public bool IsReadOnly
        {
            get
            {
                return _pageSetResults.IsReadOnly;
            }
        }

        object System.Collections.IList.this[int index]
        {
            get
            {
                return this._pageSetResults[index];
            }
            set
            {
                this._pageSetResults[index] = value;
            }
        }

        public void RemoveAt(int index)
        {
            _pageSetResults.RemoveAt(index);
        }

        public void Insert(int index, object value)
        {
            _pageSetResults.Insert(index, value);
        }

        public void Remove(object value)
        {
            _pageSetResults.Remove(value);
        }

        public bool Contains(object value)
        {
            return _pageSetResults.Contains(value);
        }

        public void Clear()
        {
            _pageSetResults.Clear();
        }

        public int IndexOf(object value)
        {
            return _pageSetResults.IndexOf(value);
        }

        public int Add(object value)
        {
            return _pageSetResults.Add(value);
        }

        public bool IsFixedSize
        {
            get
            {
                return _pageSetResults.IsFixedSize;
            }
        }

        #endregion

        #region ICollection Members

        public bool IsSynchronized
        {
            get
            {
                return _pageSetResults.IsSynchronized;
            }
        }

        public int Count
        {
            get
            {
                return _pageSetResults.Count;
            }
        }

        public void CopyTo(Array array, int index)
        {
            _pageSetResults.CopyTo(array, index);
        }

        public object SyncRoot
        {
            get
            {
                return _pageSetResults.SyncRoot;
            }
        }

        #endregion

        #region IEnumerable Members

        public IEnumerator GetEnumerator()
        {
            return _pageSetResults.GetEnumerator();
        }

        #endregion

        #region IListSource Members

        public IList GetList()
        {
            return this._pageSetResults;
        }

        public bool ContainsListCollection
        {
            get
            {
                return true;
            }
        }

        #endregion

        #region ISerializable Members
        /// <summary>
        /// Allwos overriding in inheriting classes
        /// </summary>
        /// <param name="info"></param>
        /// <param name="context"></param>
        public virtual void GetObjectData(System.Runtime.Serialization.SerializationInfo info,
            System.Runtime.Serialization.StreamingContext context)
        {
            info.AddValue("AllResults", this.AllResults);
            info.AddValue("PageSetResults", this.PageSetResults);
        }

        #endregion
    }
}



<script runat="template">
#region Public Methods
public enum AccessibilityEnum
{
    Public,
    Protected,
    Internal,
    ProtectedInternal,
    Private
}

public override string GetFileName()
{
	return this.GetClassName() + ".cs";
}


public string GetClassName()
{
	return "CollectionsBase";	
}
#endregion



</script>