<%@ CodeTemplate Language="C#" TargetLanguage="C#" Debug="False" 
    Description="Linq to Sql DataContext Class." %>

<%@ Assembly Name="Dbml" Path="..\..\Common" %>
<%@ Assembly Name="Generator" Path="..\..\Common" %>

<%@ Import Namespace="System.Text" %>
<%@ Import Namespace="LinqToSqlShared.DbmlObjectModel" %>
<%@ Import Namespace="LinqToSqlShared.Generator" %>

<%@ Property Category="1.Mapping" Name="Database" 
    Type="LinqToSqlShared.DbmlObjectModel.Database" Optional="False" 
    Description="Database schema instance. Must be set by parent template" %>

<%@ Property Category="2.Class" Name="Framework"
    Type="LinqToSqlShared.Generator.FrameworkEnum" Default="v35_SP1" Optional="False"
    Description="Which version of the .Net Framework is being generated for." %>

<%@ Property Category="2.Class" Name="IncludeDataServices"
    Type="System.Boolean" Default="true" Optional="False"
    Description="Include ADO.Net DataServices attributes and impliment IUpdatable on DataContext." %>

<%@ Map Name="CSharpKeyWordEscape" 
    Src="CSharpKeyWordEscape.csmap" Reverse="False" 
    Description="Mapping to escape c# keywords" %>

<%@ Map Name="CSharpAlias" 
    Src="System-CSharpAlias.csmap" Reverse="False" 
    Description="Convert system data types to c# alias" %>

//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a CodeSmith Template.
//
//     DO NOT MODIFY contents of this file. Changes to this
//     file will be lost if the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Configuration;
using System.Data;
using System.Data.Linq;
using System.Data.Linq.Mapping;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Web.DynamicData;
<% if (Database.ContextNamespace != Database.EntityNamespace) { %>
using <%= Database.EntityNamespace %>;
<% } %>
<% if (IncludeIUpdatable) { %>
using System.Data.Services;
<% } %>

namespace <%= Database.ContextNamespace %>
{
    /// <summary>
    /// The DataContext class for the <%= Database.Name %> database.
    /// </summary>
    <%= Naming.GetModifier(Database.AccessModifier) %> partial class <%= Database.Class %> : DataContext<% if (IncludeIUpdatable) { %>, IUpdatable<% } %>
    {
        private static MappingSource mappingCache = new AttributeMappingSource();
        
        #region ConnectionString
        private const string CONNECTION_NAME = "<%= Database.Connection.SettingsPropertyName %>";
        private static volatile string _connectionString;
        private static object _connectionLock = new Object();

        /// <summary>The application connection string read from web.config or app.config</summary>
        /// <example>
        /// Add the following key to the "connectionStrings" section of your config:
        /// <code><![CDATA[
        /// <configuration>
        ///     <connectionStrings>
        ///         <add name="<%= Database.Connection.SettingsPropertyName %>" 
        ///             connectionString="Data Source=(local);Initial Catalog=DATABASE;Integrated Security=True"
        ///             providerName="System.Data.SqlClient" />
        ///     </connectionStrings>
        /// </configuration>
        /// ]]></code>
        /// </example>
        public static string ConnectionString
        {
            get
            {
                if (_connectionString == null)
                {
                    lock (_connectionLock)
                    {
                        if (_connectionString == null)
                            _connectionString = GetDefaultConnectionString();
                    }
                }
                return _connectionString;
            }
        }

        private static string GetDefaultConnectionString()
        {
            ConnectionStringSettings settings = ConfigurationManager.ConnectionStrings[CONNECTION_NAME];
            if (settings == null)
            {
                string message = string.Format("Could not find the connection string '{0}' in the configuration file.  " +
                       "Please add an entry to connectionStrings section named '{0}'.", CONNECTION_NAME);
                throw new ConfigurationErrorsException(message);
            }
            return settings.ConnectionString;
        } 
        #endregion
        
        #region Constructors
        /// <summary>
        /// Initializes the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        [DebuggerNonUserCodeAttribute]
        static <%= Database.Class %>()
        { }

        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        [DebuggerNonUserCodeAttribute]
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>()
            : base(ConnectionString, mappingCache)
        {
            OnCreated();
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        /// <param name="connection">The connection string.</param>
        [DebuggerNonUserCodeAttribute]
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>(string connection)
            : base(connection, mappingCache)
        {
            OnCreated();
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        /// <param name="connection">The database connection.</param>
        [DebuggerNonUserCodeAttribute]
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>(IDbConnection connection)
            : base(connection, mappingCache)
        {
            OnCreated();
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        /// <param name="connection">The connection string.</param>
        /// <param name="mappingSource">The mapping source.</param>
        [DebuggerNonUserCodeAttribute]
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>(string connection, MappingSource mappingSource)
            : base(connection, mappingSource)
        {
            OnCreated();
        }
        
        /// <summary>
        /// Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        /// </summary>
        /// <param name="connection">The database connection.</param>
        /// <param name="mappingSource">The mapping source.</param>
        [DebuggerNonUserCodeAttribute]
        <%= Naming.GetModifier(Database.AccessModifier) %> <%= Database.Class %>(IDbConnection connection, MappingSource mappingSource)
            : base(connection, mappingSource)
        {
            OnCreated();
        }
        #endregion
        
        #region Tables
<% foreach (Table table in Database.Tables) { %>
        /// <summary>Represents the <%= table.Name %> table in the underlying database.</summary>
        <%= Naming.GetModifier(table.AccessModifier, table.Modifier) %> Table<<%= table.Type.Name %>> <%= GetName(table) %>
        {
            get { return GetTable<<%= table.Type.Name %>>(); }
        }
        
<% } %>
        #endregion

        #region Functions
<% foreach (Function function in Database.Functions) { %>
        /// <summary>Method that is mapped to the <%= function.Name %> database procedure.</summary>
        /// <returns></returns>
        <%= CreateAttribute(function) %>
        <%= Naming.GetModifier(function.AccessModifier, function.Modifier) %> <%= GetReturnType(function) %> <%= function.Method %>(<%= GetArguments(function) %>)
        {
            IExecuteResult result = this.ExecuteMethodCall(this,
                ((MethodInfo)(MethodInfo.GetCurrentMethod()))<%= GetArgumentNames(function) %>);
            
<% 
for(int x = 0; x < function.Parameters.Count; x++) {
    Parameter p = function.Parameters[x];

    if (p.Direction == LinqToSqlShared.DbmlObjectModel.ParameterDirection.In)
        continue;
    
    //set out params
    Response.WriteLine("            {0} = (({1})(result.GetParameterValue({2})));",
        p.ParameterName, GetParameterType(p), x);
}
%>
            
            return ((<%= GetReturnType(function) %>)(result.ReturnValue));
        }

<% } %>
        #endregion

        #region Extensibility Method Definitions
        /// <summary>Called after this instance is created.</summary>
        partial void OnCreated();
<% foreach (Table table in Database.Tables) { %>
        /// <summary>Called before a <%= table.Type.Name %> is inserted.</summary>
        /// <param name="instance">The instance.</param>
        partial void Insert<%= table.Type.Name %>(<%= table.Type.Name %> instance);
        /// <summary>Called before a <%= table.Type.Name %> is updated.</summary>
        /// <param name="instance">The instance.</param>
        partial void Update<%= table.Type.Name %>(<%= table.Type.Name %> instance);
        /// <summary>Called before a <%= table.Type.Name %> is deleted.</summary>
        /// <param name="instance">The instance.</param>
        partial void Delete<%= table.Type.Name %>(<%= table.Type.Name %> instance);
<% } %>
        #endregion
        
        <% if (IncludeIUpdatable) { %>
        #region IUpdatable Members

        // Special thanks to Mike Taulty; this is his implimentation of IUpdatable.
        // http://mtaulty.com/CommunityServer/blogs/mike_taultys_blog/archive/category/1005.aspx

        public void AddReferenceToCollection(object targetResource, string propertyName, object resourceToBeAdded)
        {
            Type t = targetResource.GetType();

            PropertyInfo collectionProperty = GetPropertyInfoForType(t, propertyName, false);

            object collection = collectionProperty.GetValue(targetResource, null);

            collection.GetType().InvokeMember("Add",
              BindingFlags.Public | BindingFlags.Instance | BindingFlags.InvokeMethod,
              null, collection, new object[] { resourceToBeAdded });
        }
        public void ClearChanges()
        {
            // This method is somewhat "tricky"
            // 1) We want to use a partial class because we want to pick up the
            //    public IQueryable<T> properties that have been generated by the tooling.
            // 2) We need to have the same class implement IUpdatable as the class that
            //    we provide to DataService<T>.
            // 3) There is no public method on DataContext that will clear everything down 
            //    without disposing but there is an internal method, ClearCache() which 
            //    looks perfect.
            // 4) Ideally here we'd get rid of the DataContext and start again but we can't
            //    because this code _is_ part of DataContext and (1) to (3) above seem to
            //    box us in.

            // Hence...
            MethodInfo mi = this.GetType().GetMethod("ClearCache",
              BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.InvokeMethod);

            mi.Invoke(this, null);
        }
        public object CreateResource(string containerName, string fullTypeName)
        {
            Type t = Type.GetType(fullTypeName);

            ITable table = GetTableForType(t);

            object value = Construct(t);

            table.InsertOnSubmit(value);

            return (value);
        }
        public void DeleteResource(object targetResource)
        {
            ITable table = this.GetTable(targetResource.GetType());

            if (table == null)
            {
                throw new DataServiceException("Failed to locate table for resource");
            }
            table.DeleteOnSubmit(targetResource);
        }
        public object GetResource(IQueryable query, string fullTypeName)
        {
            object result = null;

            foreach (object item in query)
            {
                if (result != null)
                {
                    throw new DataServiceException("A single resource is expected");
                }
                result = item;
            }
            if (result == null)
            {
                throw new DataServiceException(404, "Resource not found");
            }
            if (fullTypeName != null)
            {
                if (result.GetType().FullName != fullTypeName)
                {
                    throw new DataServiceException("Resource type mismatch");
                }
            }
            return (result);
        }
        public object GetValue(object targetResource, string propertyName)
        {
            Type t = targetResource.GetType();

            PropertyInfo pi = GetPropertyInfoForType(t, propertyName, false);

            object value = null;

            try
            {
                value = pi.GetValue(targetResource, null);
            }
            catch (Exception ex)
            {
                throw new DataServiceException(string.Format(
                  "Failed getting property {0} value", propertyName), ex);
            }
            return (value);
        }
        public void RemoveReferenceFromCollection(object targetResource, string propertyName, object resourceToBeRemoved)
        {
            Type t = targetResource.GetType();

            PropertyInfo collectionProperty = GetPropertyInfoForType(t, propertyName, false);

            object collection = collectionProperty.GetValue(targetResource, null);

            collection.GetType().InvokeMember("Remove",
              BindingFlags.Public | BindingFlags.Instance | BindingFlags.InvokeMethod,
              null, collection, new object[] { resourceToBeRemoved });
        }
        public object ResolveResource(object resource)
        {
            return (resource);
        }
        public void SaveChanges()
        {
            base.SubmitChanges();
        }
        public void SetReference(object targetResource, string propertyName, object propertyValue)
        {
            this.SetValue(targetResource, propertyName, propertyValue);
        }
        public void SetValue(object targetResource, string propertyName, object propertyValue)
        {
            Type t = targetResource.GetType();

            PropertyInfo pi = GetPropertyInfoForType(t, propertyName, true);

            try
            {
                pi.SetValue(targetResource, propertyValue, null);
            }
            catch (Exception ex)
            {
                throw new DataServiceException(
                  string.Format("Error setting property {0} to {1}", propertyName, propertyValue),
                  ex);
            }
        }
        private PropertyInfo GetPropertyInfoForType(Type t, string propertyName, bool setter)
        {
            PropertyInfo pi = null;

            try
            {
                BindingFlags flags = BindingFlags.Public | BindingFlags.Instance;
                flags |= setter ? BindingFlags.SetProperty : BindingFlags.GetProperty;

                pi = t.GetProperty(propertyName, flags);

                if (pi == null)
                {
                    throw new DataServiceException(string.Format("Failed to find property {0} on type {1}",
                      propertyName, t.Name));
                }
            }
            catch (Exception exception)
            {
                throw new DataServiceException(
                  string.Format("Error finding property {0}", propertyName),
                  exception);
            }
            return (pi);
        }
        private ITable GetTableForType(Type t)
        {
            ITable table = this.GetTable(t);

            if (table == null)
            {
                throw new DataServiceException(
                  string.Format("No table found for type {0}", t.Name));
            }
            return (table);
        }
        private static object Construct(Type t)
        {
            ConstructorInfo ci = t.GetConstructor(Type.EmptyTypes);

            if (ci == null)
            {
                throw new DataServiceException(
                  string.Format("No default ctor found for type {0}", t.Name));
            }
            return (ci.Invoke(null));
        }

        public object ResetResource(object resource)
        {
            throw new NotImplementedException();
        }

        #endregion
        <% } %>
    }
}

<script runat="template">
    public bool IncludeIUpdatable
    {
        get { return (this.Framework == FrameworkEnum.v35_SP1 && this.IncludeDataServices); }
    }

    public string CreateAttribute(Function f)
    {
        StringBuilder s = new StringBuilder();
        s.Append("[Function(");
        s.AppendFormat("Name=\"{0}\"", f.Name);
        if (f.IsComposable == true)
            s.Append(", IsComposable=true");
        s.Append(")]");
        
        return s.ToString();
    }
    public string GetName(Table table)
    {
        string name = string.IsNullOrEmpty(table.Member) ? table.Type.Name : table.Member;
        return name;
    }
    
    public string GetReturnType(Function function)
    {
        StringBuilder s = new StringBuilder();
        
        if (function.Types.Count == 0)
            s.Append(CSharpAlias[function.Return.Type]);
        else if (function.HasMultipleResults == true)
            s.Append("IMultipleResults");
        else
            s.AppendFormat("ISingleResult<{0}>", GetResultName(function));
        
        return s.ToString();
    }
    
    public string GetResultName(Function function)
    {
        if (function.Types.Count == 0)
            return string.Empty;
        
        LinqToSqlShared.DbmlObjectModel.Type resultType = function.Types[0];
        return function.Types[0].Name;        
    }
    
    public string GetArguments(Function function)
    {
        StringBuilder s = new StringBuilder();
        
        for(int x = 0; x < function.Parameters.Count; x++)
        {
            Parameter p = function.Parameters[x];
            s.AppendLine();
            s.AppendFormat("            [Parameter(DbType=\"{0}\")] ", p.DbType);

            if (p.Direction != LinqToSqlShared.DbmlObjectModel.ParameterDirection.In)
                s.Append("ref ");
            
            s.AppendFormat("{0} {1}",GetParameterType(p), p.ParameterName);
                
            if (x < function.Parameters.Count - 1)
                s.Append(", ");
        }
        
        return s.ToString();
    }
    
    public string GetParameterType(Parameter p)
    {
        if (CommonUtility.IsNullableType(p.Type))
            return CSharpAlias[p.Type] + "?";
        else
            return CSharpAlias[p.Type];
    }
    
    public string GetArgumentNames(Function function)
    {
        StringBuilder s = new StringBuilder();
        
        for(int x = 0; x < function.Parameters.Count; x++)
        {
            if (x < function.Parameters.Count)
                s.Append(", ");

            Parameter p = function.Parameters[x];
            s.Append(p.ParameterName);
        }
        
        return s.ToString();
    }
</script>