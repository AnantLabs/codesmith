<%@ CodeTemplate Language="C#" TargetLanguage="C#" Debug="True" 
    Description="Linq to Sql Entity Class." %>
    
<%@ Assembly Name="Generator" Path="..\..\Common"%>
<%@ Import Namespace="LinqToSqlShared.Generator" %>

<%@ Property Category="2.Class" Name="ClassNamespace" 
    Type="System.String" Default="Project.Core.Data" Optional="False" 
    Description="The namespace to use for the generated class files."%>

<%@ Property Category="2.Class" Name="ClassName" 
    Type="System.String" Default="LinqEntityBase" Optional="False" 
    Description="The names of the class."%>
    
<%@ Property Category="2.Class" Name="IncludeDataContract"
     Type="System.Boolean" Default="true" Optional="False"
     Description="Include WCF DataContract attributes." %>

<%@ Property Category="2.Class" Name="Framework"
    Type="FrameworkEnum" Default="v35_SP1" Optional="False"
    Description="Include Serialization attributes and what kind." %>

using System;
using System.ComponentModel;
using System.IO;
using System.Data.Linq;
using System.Linq;
<%if(IncludeDataContract)%>
using System.Runtime.Serialization;

namespace <%= ClassNamespace %>
{
    /// <summary>
    /// A base class for Linq entities that implements notification events.
    /// </summary>
    [Serializable]
    <%if (IncludeDataContract) { %>
    [DataContract(<%if (Framework == FrameworkEnum.v35_SP1) { %> IsReference=true <%}%>)]
    <%}%>
    public abstract partial class <%= ClassName %> :
        INotifyPropertyChanging,
        INotifyPropertyChanged,
        ICloneable
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="<%= ClassName %>"/> class.
        /// </summary>
        protected <%= ClassName %>()
        { }

        #region Notification Events

        /// <summary>
        /// Implements a PropertyChanged event.
        /// </summary>
        [field: NonSerialized]
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// Raise the PropertyChanged event for a specific property.
        /// </summary>
        /// <param name="propertyName">Name of the property that has changed.</param>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void SendPropertyChanged(string propertyName)
        {
            if (PropertyChanged != null)
                PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
        }

        /// <summary>
        /// Implements a PropertyChanging event.
        /// </summary>
        [field: NonSerialized]
        public event PropertyChangingEventHandler PropertyChanging;

        /// <summary>
        /// Raise the PropertyChanging event for a specific property.
        /// </summary>
        /// <param name="propertyName">Name of the property that is changing.</param>
        [EditorBrowsable(EditorBrowsableState.Advanced)]
        protected virtual void SendPropertyChanging(string propertyName)
        {
            if (PropertyChanging != null)
                PropertyChanging(this, new PropertyChangingEventArgs(propertyName));
            
        }
        #endregion
        
        /// <summary>
        /// Creates a new object that is a copy of the current instance.
        /// </summary>
        /// <returns>
        /// A new object that is a copy of this instance.
        /// </returns>
        object ICloneable.Clone()
        {
<%if (IncludeDataContract) { %>
            DataContractSerializer serializer = new DataContractSerializer(GetType());
            using (MemoryStream ms = new MemoryStream())
            {
                serializer.WriteObject(ms, this);
                ms.Position = 0;
                return serializer.ReadObject(ms);
            }
<%} else {%>
            using (MemoryStream ms = new MemoryStream())
            {
                BinaryFormatter formatter = new BinaryFormatter();
                formatter.Serialize(ms, this);
                ms.Position = 0;
                return formatter.Deserialize(ms);
            }
<%}%>
        }
        #region "Detach Methods"
        
        public bool IsAttached
        {
            get { return PropertyChanging != null; }
        }
        
        /// <summary>
        /// Detach this instance from the <see cref="DataContext"/>.
        /// </summary>
        /// <remarks>
        /// Detaching the entity will allow it to be attached to another <see cref="DataContext"/>.
        /// </remarks>
        public virtual void Detach()
        {
            PropertyChanging = null;
            PropertyChanged = null;
        }
        
        /// <summary>
        /// Detach the specified <see cref="T:System.Data.Linq.EntitySet`1" />.
        /// </summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="set">The <see cref="T:System.Data.Linq.EntitySet`1" /> to detach.</param>
        /// <param name="onAdd">Delegate for <see cref="M:System.Data.Linq.EntitySet`1.Add(`0)" />.</param>
        /// <param name="onRemove">Delegate for <see cref="M:System.Data.Linq.EntitySet`1.Remove(`0)" />.</param>
        /// <returns>A new <see cref="T:System.Data.Linq.EntitySet`1" /> with the list copied if it was loaded.</returns>
        protected static EntitySet<TEntity> Detach<TEntity>(EntitySet<TEntity> set, Action<TEntity> onAdd, Action<TEntity> onRemove) 
            where TEntity : LinqEntityBase
        {
            if (set == null || !set.HasLoadedOrAssignedValues)
                return new EntitySet<TEntity>(onAdd, onRemove);

            // copy list and detach all entities
            var list = set.ToList();
            list.ForEach(t => t.Detach());

            var newSet = new EntitySet<TEntity>(onAdd, onRemove);
            newSet.Assign(list);
            return newSet;
        }

        /// <summary>
        /// Detach the specified <see cref="T:System.Data.Linq.EntityRef`1"/>.
        /// </summary>
        /// <typeparam name="TEntity">The type of the entity.</typeparam>
        /// <param name="entity">The <see cref="T:System.Data.Linq.EntityRef`1"/> to detach.</param>
        /// <returns>A new <see cref="T:System.Data.Linq.EntityRef`1"/> with the entity detached.</returns>
        protected static EntityRef<TEntity> Detach<TEntity>(EntityRef<TEntity> entity) 
            where TEntity : LinqEntityBase
        {
            if (!entity.HasLoadedOrAssignedValue)
                return new EntityRef<TEntity>();

            entity.Entity.Detach();
            return new EntityRef<TEntity>(entity.Entity);
        }
        
        #endregion
    }
}