<%@ CodeTemplate Language="VB" TargetLanguage="VB" Debug="False" 
    Description="Linq to Sql DataContext Class." %>

<%@ Assembly Name="Dbml" Path="..\..\Common" %>
<%@ Assembly Name="Generator" Path="..\..\Common" %>

<%@ Import Namespace="System.Text" %>
<%@ Import Namespace="LinqToSqlShared.DbmlObjectModel" %>
<%@ Import Namespace="LinqToSqlShared.Generator" %>

<%@ Property Category="1.Mapping" Name="Database" 
    Type="LinqToSqlShared.DbmlObjectModel.Database" Optional="False" 
    Description="Database schema instance. Must be set by parent template" %>

<%@ Property Category="2.Class" Name="Framework"
    Type="LinqToSqlShared.Generator.FrameworkEnum" Default="v35_SP1" Optional="False"
    Description="Which version of the .Net Framework is being generated for." %>

<%@ Property Category="2.Class" Name="IncludeDataServices"
    Type="System.Boolean" Default="true" Optional="False"
    Description="Include ADO.Net DataServices attributes and impliment IUpdatable on DataContext." %>

<%@ Property Category="2.Class" Name="IncludeDataRules"
    Type="System.Boolean" Default="true" Optional="False"
    Description="Include CodeSmith.Data rules." %>
    
<%@ Property Category="2.Class" Name="DefaultConnectionString"
    Type="System.String" Optional="True"
    Description="Default Connection String Name for DatabaseContext." %>
    
<%@ Map Name="VBKeywordEscape" 
    Src="VBKeywordEscape.csmap" Reverse="False" 
    Description="Mapping to escape c# keywords" %>

<%@ Map Name="VBAlias" 
    Src="System-VBAlias.csmap" Reverse="False" 
    Description="Convert system data types to c# alias" %>

'------------------------------------------------------------------------------
' <autogenerated>
'     This code was generated by a CodeSmith Template.
'
'     DO Not MODIfY contents of this file. Changes to this
'     file will be lost if the code is regenerated.
' </autogenerated>
'------------------------------------------------------------------------------


Imports System
Imports System.Collections.Generic
Imports System.ComponentModel
Imports System.Configuration
Imports System.Data
Imports System.Data.Linq
Imports System.Data.Linq.Mapping
Imports System.Diagnostics
Imports System.Linq
Imports System.Reflection
<% If Not Database.ContextNamespace = Database.EntityNamespace Then %>
Imports <%= Database.EntityNamespace %>
<% End If %>
<% If (IncludeIUpdatable) Then %>
Imports System.Data.Services
<% End If %>
<% If (IncludeDataRules) Then %>
Imports CodeSmith.Data.Rules
<% End If %>

Namespace <%= Database.ContextNamespace %>
    ''' <summary>
    ''' The DataContext class for the <%= Database.Name %> database.
    ''' </summary>
    <%= Naming.GetModifier(Database.AccessModifier) %> Partial Class <%= Database.Class %> 
    Inherits DataContext
<% If (IncludeIUpdatable) Then %>
    Implements IUpdatable
<% End If %>
        Private Shared ReadOnly mappingCache As MappingSource = New AttributeMappingSource()

        #Region "ConnectionString"
        Private Const CONNECTION_NAME As String = "<%= IIF(DefaultConnectionString IS NOTHING,Database.Connection.SettingsPropertyName,DefaultConnectionString) %>"
        Private Shared _connectionString As String
        Private Shared _connectionLock As New Object()
        
        ''' <summary>The application connection string read from web.config or app.config</summary>
        ''' <example>
        ''' Add the following key to the "connectionStrings" section of your config:
        ''' <code><![CDATA[
        ''' <configuration>
        '''     <connectionStrings>
        '''         <add name="<%= Database.Connection.SettingsPropertyName %>" 
        '''             connectionString="Data Source=(local);Initial Catalog=DATABASE;Integrated Security=True"
        '''             providerName="System.Data.SqlClient" />
        '''     </connectionStrings>
        ''' </configuration>
        ''' ]]></code>
        ''' </example>
        Public Shared ReadOnly Property ConnectionString() As String
        
            Get
                If _connectionString Is Nothing Then
                    SyncLock _connectionLock
                    If _connectionString Is Nothing Then
                        _connectionString = GetDefaultConnectionString()
                    End If
                    End SyncLock
                End If
                Return _connectionString
            End Get
        End Property
        
        Private Shared Function GetDefaultConnectionString() As String
            Dim settings As ConnectionStringSettings = ConfigurationManager.ConnectionStrings(CONNECTION_NAME)
            If settings Is Nothing Then
                Dim message As String = String.Format("Could not find the connection string '{0}' in the configuration file.  " + "Please add an entry to connectionStrings section named '{0}'.", CONNECTION_NAME)
                Throw New ConfigurationErrorsException(message)
            End If
            Return settings.ConnectionString
        End Function
        #End Region

        #Region "Constructors"

        ''' <summary>
        ''' Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        ''' </summary>
        <DebuggerNonUserCodeAttribute> _
        <%= Naming.GetModifier(Database.AccessModifier) %> Sub New()
            MyBase.New(ConnectionString, mappingCache)
            OnCreated()
        End Sub

        
        ''' <summary>
        ''' Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        ''' </summary>
        ''' <param name="connection">The connection string.</param>
        <DebuggerNonUserCodeAttribute> _
        <%= Naming.GetModifier(Database.AccessModifier) %> Sub New(ByVal connection As String)
            MyBase.New(connection, mappingCache)
            OnCreated()
        End Sub
        
        ''' <summary>
        ''' Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        ''' </summary>
        ''' <param name="connection">The database connection.</param>
        <DebuggerNonUserCodeAttribute> _
        <%= Naming.GetModifier(Database.AccessModifier) %> Sub New(ByVal connection As IDbConnection)
            MyBase.New(connection, mappingCache)
            OnCreated()
        End Sub
        
        ''' <summary>
        ''' Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        ''' </summary>
        ''' <param name="connection">The connection string.</param>
        ''' <param name="mappingSource">The mapping source.</param>
        <DebuggerNonUserCodeAttribute> _
        <%= Naming.GetModifier(Database.AccessModifier) %> Sub New(ByVal connection As String, ByVal mappingSource As MappingSource)
            MyBase.New(connection, mappingSource)
            OnCreated()
        End Sub
        
        ''' <summary>
        ''' Initializes a new instance of the <see cref="<%= Database.Class %>"/> class.
        ''' </summary>
        ''' <param name="connection">The database connection.</param>
        ''' <param name="mappingSource">The mapping source.</param>
        <DebuggerNonUserCodeAttribute> _
        <%= Naming.GetModifier(Database.AccessModifier) %> Sub New(ByVal connection As IDbConnection, ByVal mappingSource As MappingSource)
            MyBase.New(connection, mappingSource)
            OnCreated()
        End Sub
        #End Region
        
        #Region "Tables"
<% For Each table As Table In Database.Tables  %>
        ''' <summary>Represents the <%= table.Name %> table in the underlying database.</summary>
        <%= Naming.GetModifier(table.AccessModifier, table.Modifier) %> ReadOnly Property <%= GetName(table) %> As Table(Of <%= table.Type.Name %>)
            Get
                Return GetTable(Of <%= table.Type.Name %>)()
            End Get
        End Property
        
<% Next %>
        #End Region

        #region "Functions"
<% For Each f As [Function] in Database.Functions %>
        ''' <summary>Method that is mapped to the <%= f.Name %> database procedure.</summary>
        ''' <returns></returns>
        <%= CreateAttribute(f) %>
        <%= Naming.GetModifier(f.AccessModifier, f.Modifier) %>  Function <%= f.Method %>(<%= GetArguments(f) %>) As <%= GetReturnType(f) %>

            Dim result As IExecuteResult = Me.ExecuteMethodCall(Me, _
                (DirectCast(MethodInfo.GetCurrentMethod(),MethodInfo))<%= GetArgumentNames(f) %>)
            
<% 
Dim x As Integer
For x = 0 TO f.Parameters.Count - 1
    Dim p As Parameter = f.Parameters(x)


    If (p.Direction.Value = LinqToSqlShared.DbmlObjectModel.ParameterDirection.In) Then
        Continue For
    End If

    'set out params
    Response.WriteLine("            {0} = (DirectCast(result.GetParameterValue({2}),{1}))",p.ParameterName, GetParameterType(p), x)
Next
%>
            
            Return (DirectCast((result.ReturnValue),<%= GetReturnType(f) %>))
        End Function

<% Next %>
        #End Region

        #Region "Extensibility Method Definitions"
        ''' <summary>Called after this instance is created.</summary>
        Partial Private Sub OnCreated()
        End Sub
<% For Each [table] As [Table] in Database.Tables %>
        ''' <summary>Called before a <%= [table].Type.Name %> is inserted.</summary>
        ''' <param name="instance">The instance.</param>
        Partial Private Sub Insert<%= [table].Type.Name %>(ByVal instance As <%= [table].Type.Name %>)
        End Sub
        ''' <summary>Called before a <%= [table].Type.Name %> is updated.</summary>
        ''' <param name="instance">The instance.</param>
        Partial Private Sub Update<%= [table].Type.Name %>(ByVal instance As <%= [table].Type.Name %>)
        End Sub
        ''' <summary>Called before a <%= [table].Type.Name %> is deleted.</summary>
        ''' <param name="instance">The instance.</param>
        Partial Private Sub Delete<%= [table].Type.Name %>(ByVal instance As <%= [table].Type.Name %>)
        End Sub
<% Next %>
        #End Region

<% If (IncludeIUpdatable) Then %>
        #Region "IUpdatable Members"

        ' Special thanks to Mike Taulty; this is his implimentation of IUpdatable.
        ' http://mtaulty.com/CommunityServer/blogs/mike_taultys_blog/archive/category/1005.aspx
    
        Public Sub AddReferenceToCollection(ByVal targetResource As Object, ByVal propertyName As String, ByVal resourceToBeAdded As Object) Implements IUpdatable.AddReferenceToCollection
            Dim t As Type = targetResource.[GetType]()
    
            Dim collectionProperty As PropertyInfo = GetPropertyInfoForType(t, propertyName, False)
    
            Dim collection As Object = collectionProperty.GetValue(targetResource, Nothing)
    
            collection.[GetType]().InvokeMember("Add", BindingFlags.[Public] Or BindingFlags.Instance Or BindingFlags.InvokeMethod, Nothing, collection, New Object() {resourceToBeAdded})
        End Sub
        
        Public Sub ClearChanges() Implements IUpdatable.ClearChanges
            ' This method is somewhat "tricky"
            ' 1) We want to use a partial class because we want to pick up the
            '    public IQueryable<T> properties that have been generated by the tooling.
            ' 2) We need to have the same class implement IUpdatable as the class that
            '    we provide to DataService<T>.
            ' 3) There is no public method on DataContext that will clear everything down 
            '    without disposing but there is an internal method, ClearCache() which 
            '    looks perfect.
            ' 4) Ideally here we'd get rid of the DataContext and start again but we can't
            '    because this code _is_ part of DataContext and (1) to (3) above seem to
            '    box us in.
    
            ' Hence...
            Dim mi As MethodInfo = Me.[GetType]().GetMethod("ClearCache", BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.InvokeMethod)
    
            mi.Invoke(Me, Nothing)
        End Sub
        
        Public Function CreateResource(ByVal containerName As String, ByVal fullTypeName As String) As Object Implements IUpdatable.CreateResource
            Dim t As Type = Type.[GetType](fullTypeName)
    
            Dim table As ITable = GetTableForType(t)
    
            Dim value As Object = Construct(t)
    
            table.InsertOnSubmit(value)
    
            Return (value)
        End Function
        
        Public Sub DeleteResource(ByVal targetResource As Object) Implements IUpdatable.DeleteResource
            Dim table As ITable = Me.GetTable(targetResource.[GetType]())
    
            If table Is Nothing Then
                Throw New DataServiceException("Failed to locate table for resource")
            End If
            table.DeleteOnSubmit(targetResource)
        End Sub
        
        Public Function GetResource(ByVal query As IQueryable, ByVal fullTypeName As String) As Object Implements IUpdatable.GetResource
            Dim result As Object = Nothing
    
            For Each item As Object In query
                If result <> Nothing Then
                    Throw New DataServiceException("A single resource is expected")
                End If
                result = item
            Next
            If result = Nothing Then
                Throw New DataServiceException(404, "Resource not found")
            End If
            If fullTypeName <> Nothing Then
                If result.[GetType]().FullName <> fullTypeName Then
                    Throw New DataServiceException("Resource type mismatch")
                End If
            End If
            Return (result)
        End Function
        
        Public Function GetValue(ByVal targetResource As Object, ByVal propertyName As String) As Object Implements IUpdatable.GetValue
            Dim t As Type = targetResource.[GetType]()
    
            Dim pi As PropertyInfo = GetPropertyInfoForType(t, propertyName, False)
    
            Dim value As Object = Nothing
    
            Try
                value = pi.GetValue(targetResource, Nothing)
            Catch ex As Exception
                Throw New DataServiceException(String.Format("Failed getting property {0} value", propertyName), ex)
            End Try
            Return (value)
        End Function
        
        Public Sub RemoveReferenceFromCollection(ByVal targetResource As Object, ByVal propertyName As String, ByVal resourceToBeRemoved As Object) Implements IUpdatable.RemoveReferenceFromCollection
            Dim t As Type = targetResource.[GetType]()
    
            Dim collectionProperty As PropertyInfo = GetPropertyInfoForType(t, propertyName, False)
    
            Dim collection As Object = collectionProperty.GetValue(targetResource, Nothing)
    
            collection.[GetType]().InvokeMember("Remove", BindingFlags.[Public] Or BindingFlags.Instance Or BindingFlags.InvokeMethod, Nothing, collection, New Object() {resourceToBeRemoved})
        End Sub
        
        Public Function ResolveResource(ByVal resource As Object) As Object Implements IUpdatable.ResolveResource
            Return (resource)
        End Function
        
        Public Sub SaveChanges() Implements IUpdatable.SaveChanges
            Try
                MyBase.SubmitChanges()
            Catch ex As Exception
                Throw New DataServiceException("Error Saving Context. " + ex.GetBaseException().Message, ex)
            End Try
        End Sub
        
        Public Sub SetReference(ByVal targetResource As Object, ByVal propertyName As String, ByVal propertyValue As Object) Implements IUpdatable.SetReference
            Me.SetValue(targetResource, propertyName, propertyValue)
        End Sub
        
        Public Sub SetValue(ByVal targetResource As Object, ByVal propertyName As String, ByVal propertyValue As Object) Implements IUpdatable.SetValue
            Dim t As Type = targetResource.[GetType]()
    
            Dim pi As PropertyInfo = GetPropertyInfoForType(t, propertyName, True)
    
            Try
                pi.SetValue(targetResource, propertyValue, Nothing)
            Catch ex As Exception
                Throw New DataServiceException(String.Format("Error setting property {0} to {1}", propertyName, propertyValue), ex)
            End Try
        End Sub
        
        Private Function GetPropertyInfoForType(ByVal t As Type, ByVal propertyName As String, ByVal setter As Boolean) As PropertyInfo
            Dim pi As PropertyInfo = Nothing
    
            Try
                Dim flags As BindingFlags = BindingFlags.[Public] Or BindingFlags.Instance
                flags = flags Or IIf(setter,BindingFlags.SetProperty,BindingFlags.GetProperty)
    
                pi = t.GetProperty(propertyName, flags)
    
                If pi Is Nothing Then
                    Throw New DataServiceException(String.Format("Failed to find property {0} on type {1}", propertyName, t.Name))
                End If
            Catch exception As Exception
                Throw New DataServiceException(String.Format("Error finding property {0}", propertyName), exception)
            End Try
            Return (pi)
        End Function
        
        Private Function GetTableForType(ByVal t As Type) As ITable
            Dim table As ITable = Me.GetTable(t)
    
            If table Is Nothing Then
                Throw New DataServiceException(String.Format("No table found for type {0}", t.Name))
            End If
            Return (table)
        End Function
        
        Private Shared Function Construct(ByVal t As Type) As Object
            Dim ci As ConstructorInfo = t.GetConstructor(Type.EmptyTypes)
    
            If ci Is Nothing Then
                Throw New DataServiceException(String.Format("No default ctor found for type {0}", t.Name))
            End If
            Return (ci.Invoke(Nothing))
        End Function
    
        Public Function ResetResource(ByVal resource As Object) As Object Implements IUpdatable.ResetResource
            Throw New NotImplementedException()
        End Function
        
        #End Region
<% End If %>


        ''' <summary>
        ''' Sends changes made to retrieved objects to the underlying database.
        ''' </summary>
        ''' <param name="refreshMode">Defines how to handle optimistic concurrency conflicts.</param>
        Public Sub SubmitChanges(ByVal refreshMode As RefreshMode)
            Try
                SubmitChanges(ConflictMode.ContinueOnConflict)
            Catch generatedExceptionName As ChangeConflictException
                For Each occ In ChangeConflicts
                    occ.Resolve(refreshMode)
                Next
                
                SubmitChanges()
            End Try
        End Sub

    End Class
End Namespace

<script runat="template">
Public ReadOnly Property IncludeIUpdatable() As Boolean
    Get
        Return (Me.Framework = FrameworkEnum.v35_SP1 AndAlso Me.IncludeDataServices)
    End Get
End Property

Public Function CreateAttribute(ByVal f As [Function]) As String
    Dim s As New StringBuilder()
    s.Append("<[Function](")
    s.AppendFormat("Name:=""{0}""", f.Name)
    If f.IsComposable.Value = True Then
        s.Append(", IsComposable:=true")
    End If
    s.Append(")> _")
    
    Return s.ToString()
End Function
Public Function GetName(ByVal table As Table) As String
    Dim name As String = IIf(String.IsNullOrEmpty(table.Member),table.Type.Name,table.Member)
    Return name
End Function


Public Function GetReturnType(ByVal [function] As [Function]) As String
    Dim s As New StringBuilder()

    If [function].Types.Count = 0 Then
        s.Append(VBAlias([function].[Return].Type))
ElseIf [function].HasMultipleResults.Value = True Then
        s.Append("IMultipleResults")
    Else
        s.AppendFormat("ISingleResult(Of {0})", GetResultName([function]))
    End If
    
    Return s.ToString()
End Function

Public Function GetResultName(ByVal [function] As [Function]) As String
    If [function].Types.Count = 0 Then
        Return String.Empty
    End If
    
    Dim resultType As LinqToSqlShared.DbmlObjectModel.Type = [function].Types(0)
    Return [function].Types(0).Name
End Function

Public Function GetArguments(ByVal [function] As [Function]) As String
    Dim s As New StringBuilder()
    For x As Integer = 0 To [function].Parameters.Count - 1
        

        Dim p As Parameter = [function].Parameters(x)
        s.AppendLine(" _")
        s.AppendFormat("            <Parameter(DbType:=""{0}"")> ", p.DbType)
        

        s.AppendFormat("ByVal {1} As {0}", GetParameterType(p), p.ParameterName)
        
        If x < [function].Parameters.Count - 1 Then
            s.Append(", ")
        End If
    Next

    Return s.ToString()
End Function


Public Function GetParameterType(ByVal p As Parameter) As String
    If CommonUtility.IsNullableType(p.Type) Then
        Return VBAlias(p.Type) + "?"
    Else
        Return VBAlias(p.Type)
    End If
End Function

Public Function GetArgumentNames(ByVal [function] As [Function]) As String
    Dim s As New StringBuilder()
    For x As Integer = 0 To [function].Parameters.Count - 1
     
        If x < [function].Parameters.Count Then
            s.Append(", ")
        End If
        
        Dim p As Parameter = [function].Parameters(x)
        s.Append(p.ParameterName)
    Next
    
    Return s.ToString()
End Function

  
</script>
